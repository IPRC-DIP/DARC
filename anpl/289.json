{"funs": {"crop_grid": {"code": "def crop_grid(input_grid: np.ndarray) -> np.ndarray:\n    non_black_indices = np.where(input_grid != black)\n    min_x, max_x = (np.min(non_black_indices[0]), np.max(non_black_indices[0]))\n    min_y, max_y = (np.min(non_black_indices[1]), np.max(non_black_indices[1]))\n    return input_grid[min_x:max_x + 1, min_y:max_y + 1]", "prompt": "Crop the input grid, only keep the non-black area", "subfunctions": [], "parent": "main"}, "get_colors": {"code": "def get_colors(grid: np.ndarray) -> Tuple[int, int]:\n    colors = np.unique(grid)\n    return (colors[0], colors[1])", "prompt": null, "subfunctions": [], "parent": "main"}, "exchange_colors": {"code": "def exchange_colors(grid: np.ndarray, color1: int, color2: int) -> np.ndarray:\n    \"\"\"\n    Given a grid and two colors, exchanges the positions of the two colors in the grid.\n    \n    Args:\n    grid: A numpy array representing the grid.\n    color1: An integer representing the first color.\n    color2: An integer representing the second color.\n    \n    Returns:\n    A numpy array representing the grid with the two colors exchanged.\n    \"\"\"\n    output_grid = np.copy(grid)\n    output_grid[grid == color1] = color2\n    output_grid[grid == color2] = color1\n    return output_grid", "prompt": "exchange the two colors in the grid", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    grid1 = \"Crop the input grid, only keep the non-black area\"(input_grid)\n    color1, color2 = get_colors(grid1)\n    output_grid = \"exchange the two colors in the grid\"(grid1, color1, color2)\n    return output_grid", "prompt": null, "subfunctions": ["crop_grid", "get_colors", "exchange_colors"], "parent": null}}, "entry": "main"}
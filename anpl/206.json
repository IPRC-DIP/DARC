{"funs": {"divide_grid": {"code": "def divide_grid(input_grid: np.ndarray) -> List[np.ndarray]:\n    \"\"\"\n    Divides the input grid into four 2*2 sub-grids using the third row and the third column as the dividing line.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of four numpy arrays representing the four sub-grids.\n    \"\"\"\n    sub_grid_list = []\n    sub_grid_list.append(input_grid[:2, :2])\n    sub_grid_list.append(input_grid[:2, 3:])\n    sub_grid_list.append(input_grid[3:, :2])\n    sub_grid_list.append(input_grid[3:, 3:])\n    return sub_grid_list", "prompt": "The input grid is 5*5, and the third row and the third column are used as the dividing line to divide the grid into four 2*2 sub-grids, and return a list of four sub-grids", "subfunctions": [], "parent": "main"}, "count_non_black_blocks": {"code": "def count_non_black_blocks(sub_grid_list: List[np.ndarray]) -> List[int]:\n    \"\"\"\n    Counts the number of non-black blocks in each sub-grid and returns the answer list.\n    \n    Args:\n    sub_grid_list: A list of four numpy arrays representing the four sub-grids.\n    \n    Returns:\n    A list of four integers representing the number of non-black blocks in each sub-grid.\n    \"\"\"\n    count_list = []\n    for sub_grid in sub_grid_list:\n        count = np.count_nonzero(sub_grid != black)\n        count_list.append(count)\n    return count_list", "prompt": "Count the number of non-black blocks in each sub-grid and return the answer list", "subfunctions": [], "parent": "main"}, "get_different_subgrid": {"code": "def get_different_subgrid(sub_grid_list: List[np.ndarray], count_list: List[int]) -> np.ndarray:\n    \"\"\"\n    Traverses count_list, if one of the values is different from the other three values, returns the sub-grid corresponding to the value.\n    \n    Args:\n    sub_grid_list: A list of four numpy arrays representing the four sub-grids.\n    count_list: A list of four integers representing the number of non-black blocks in each sub-grid.\n    \n    Returns:\n    A numpy array representing the sub-grid with a different number of non-black blocks.\n    \"\"\"\n    for i in range(4):\n        if count_list.count(count_list[i]) == 1:\n            return sub_grid_list[i]", "prompt": "Traversing count_list, if one of the values is different from the other three values, return the subgrid corresponding to the value", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    sub_grid_list = \"The input grid is 5*5, and the third row and the third column are used as the dividing line to divide the grid into four 2*2 sub-grids, and return a list of four sub-grids\"(input_grid)\n    count_list = \"Count the number of non-black blocks in each sub-grid and return the answer list\"(sub_grid_list)\n    ans_grid = \"Traversing count_list, if one of the values is different from the other three values, return the subgrid corresponding to the value\"(sub_grid_list, count_list)\n    return ans_grid", "prompt": "In the input, you should see a n*n grid with multiple color pixels.", "subfunctions": ["divide_grid", "count_non_black_blocks", "get_different_subgrid"], "parent": null}}, "entry": "main"}
{"funs": {"find_red_points": {"code": "def find_red_points(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    red_points = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                red_points.append((i, j))\n    return red_points", "prompt": "Find all red points in input grid", "subfunctions": [], "parent": "main"}, "num_green_points_right": {"code": "def num_green_points_right(input_grid: np.ndarray, i: int, j: int) -> int:\n    count = 0\n    while j < input_grid.shape[1] and input_grid[i][j] != black:\n        if input_grid[i][j] == green:\n            count += 1\n        j += 1\n    return count", "prompt": "the num of green points in the right of (i,j) until meeting black point or edge", "subfunctions": [], "parent": "main"}, "color_and_mark": {"code": "def color_and_mark(input_grid: np.ndarray, i: int, j: int, length: int) -> None:\n    input_grid[i - length:i + length + 1, 0:j] = green\n    input_grid[i, 0:j] = red", "prompt": null, "subfunctions": [], "parent": "color_and_mark_areas"}, "color_and_mark_areas": {"code": "def color_and_mark_areas(input_grid: np.ndarray, i: int, j: int, length: int) -> None:\n    color_and_mark(input_grid, i, j, length)", "prompt": "color the area [i-len:i+len+1,0:j] green. Then color the area [i,0:j] red", "subfunctions": ["color_and_mark"], "parent": "main"}, "num_green_points_left": {"code": "def num_green_points_left(input_grid: np.ndarray, i: int, j: int) -> int:\n    count = 0\n    while j >= 0 and input_grid[i][j] != black:\n        if input_grid[i][j] == green:\n            count += 1\n        j -= 1\n    return count", "prompt": "the num of green points in the left of (i,j) until meeting black point or edge", "subfunctions": [], "parent": "main"}, "color_and_mark_right": {"code": "def color_and_mark_right(input_grid: np.ndarray, i: int, j: int, length: int) -> None:\n    input_grid[i - length:i + length + 1, j:input_grid.shape[1]] = green\n    input_grid[i, j:input_grid.shape[1]] = red", "prompt": "color the area [i-len:i+len+1,j:input_grid.shape[1]]  green. Then color the area [i,j:input_grid.shape[1]] red", "subfunctions": [], "parent": "main"}, "num_green_points_down": {"code": "def num_green_points_down(input_grid: np.ndarray, i: int, j: int) -> int:\n    count = 0\n    while i < input_grid.shape[0] and input_grid[i][j] != black:\n        if input_grid[i][j] == green:\n            count += 1\n        i += 1\n    return count", "prompt": "the num of green points in the down of (i,j) until meeting black point or edge", "subfunctions": [], "parent": "main"}, "color_and_mark_up": {"code": "def color_and_mark_up(input_grid: np.ndarray, i: int, j: int, length: int) -> None:\n    input_grid[0:i + 1, j - length:j + length + 1] = green\n    input_grid[0:i + 1, j] = red", "prompt": "color the area [0:i,j-len:j+len+1]  green. Then color the area [0:i,j] red", "subfunctions": [], "parent": "main"}, "num_green_points_up": {"code": "def num_green_points_up(input_grid: np.ndarray, i: int, j: int) -> int:\n    count = 0\n    while i >= 0 and input_grid[i][j] != black:\n        if input_grid[i][j] == green:\n            count += 1\n        i -= 1\n    return count", "prompt": "the num of green points in the up of (i,j) until meeting black point or edge", "subfunctions": [], "parent": "main"}, "color_and_mark_down": {"code": "def color_and_mark_down(input_grid: np.ndarray, i: int, j: int, length: int) -> None:\n    input_grid[i:i + length + 1, j - length:j + length + 1] = green\n    input_grid[i, j - length:j + length + 1] = red", "prompt": "color the area [i:input_grid.shape[0],j-len:j+len+1]  green. Then color the area [i:input_grid.shape[0],j] red", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    red_points = \"Find all red points in input grid\"(input_grid)\n    for point in red_points:\n        i, j = point\n        if input_grid[i][j - 1] == black:\n            len = \"the num of green points in the right of (i,j) until meeting black point or edge\"(input_grid, i, j)\n            \"color the area [i-len:i+len+1,0:j] green. Then color the area [i,0:j] red\"(input_grid, i, j, len)\n        elif input_grid[i][j + 1] == black:\n            len = \"the num of green points in the left of (i,j) until meeting black point or edge\"(input_grid, i, j)\n            \"color the area [i-len:i+len+1,j:input_grid.shape[1]]  green. Then color the area [i,j:input_grid.shape[1]] red\"(input_grid, i, j, len)\n        elif input_grid[i - 1][j] == black:\n            len = \"the num of green points in the down of (i,j) until meeting black point or edge\"(input_grid, i, j)\n            \"color the area [0:i,j-len:j+len+1]  green. Then color the area [0:i,j] red\"(input_grid, i, j, len)\n        elif input_grid[i + 1][j] == black:\n            len = \"the num of green points in the up of (i,j) until meeting black point or edge\"(input_grid, i, j)\n            \"color the area [i:input_grid.shape[0],j-len:j+len+1]  green. Then color the area [i:input_grid.shape[0],j] red\"(input_grid, i, j, len)\n    return input_grid", "prompt": null, "subfunctions": ["find_red_points", "num_green_points_right", "color_and_mark_areas", "num_green_points_left", "color_and_mark_right", "num_green_points_down", "color_and_mark_up", "num_green_points_up", "color_and_mark_down"], "parent": null}}, "entry": "main"}
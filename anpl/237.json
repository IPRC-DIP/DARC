{"funs": {"find_non_black_teal_pixels": {"code": "def find_non_black_teal_pixels(input_grid: np.ndarray) -> np.ndarray:\n    non_black_teal_pixels = np.where((input_grid != black) & (input_grid != teal), 1, 0)\n    return non_black_teal_pixels", "prompt": "find all not black and not teal pixels", "subfunctions": [], "parent": "main"}, "find_teal_pixels": {"code": "def find_teal_pixels(input_grid: np.ndarray) -> np.ndarray:\n    teal_pixels = np.where(input_grid == teal, 1, 0)\n    return teal_pixels", "prompt": "find all teal pixels", "subfunctions": [], "parent": "main"}, "find_smallest_area": {"code": "def find_smallest_area(input_grid: np.ndarray, t: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function finds the smallest rectangle that covers all teal pixels in the input grid.\n\n    Args:\n    - input_grid: a numpy array representing the input grid\n    - t: a numpy array representing the teal pixels in the input grid\n\n    Returns:\n    - s: a numpy array representing the smallest rectangle that covers all teal pixels in the input grid\n    \"\"\"\n    rows, cols = np.where(t == 1)\n    min_row, max_row = (np.min(rows), np.max(rows))\n    min_col, max_col = (np.min(cols), np.max(cols))\n    s = input_grid[min_row:max_row + 1, min_col:max_col + 1]\n    return s", "prompt": "get the max and min row and col of pixels in t, return the pixels between and in this four edge", "subfunctions": [], "parent": "main"}, "find_smallest_covering_area": {"code": "def find_smallest_covering_area(input_grid: np.ndarray, p: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function finds the smallest rectangle that covers all non-black teal pixels in the input grid.\n\n    Args:\n    - input_grid: a numpy array representing the input grid\n    - p: a numpy array representing the non-black teal pixels in the input grid\n\n    Returns:\n    - l: a numpy array representing the smallest rectangle that covers all non-black teal pixels in the input grid\n    \"\"\"\n    rows, cols = np.where(p == 1)\n    min_row, max_row = (np.min(rows), np.max(rows))\n    min_col, max_col = (np.min(cols), np.max(cols))\n    l = input_grid[min_row:max_row + 1, min_col:max_col + 1]\n    return l", "prompt": "get the max and min row and col of pixels in p, return the pixels between and in this four edge", "subfunctions": [], "parent": "main"}, "copy_square_to_middle": {"code": "def copy_square_to_middle(s: np.ndarray, l: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function creates a copy of l, finds the inner black area in l, and copies the square area s to the black area in the copy of l.\n\n    Args:\n    - s: a numpy array representing the smallest rectangle that covers all teal pixels in the input grid\n    - l: a numpy array representing the smallest rectangle that covers all non-black teal pixels in the input grid\n\n    Returns:\n    - out: a numpy array representing the copy of l with the square area s copied to the black area in the middle\n    \"\"\"\n    out = np.copy(l)\n    rows, cols = np.where(l == black)\n    min_row, max_row = (np.min(rows), np.max(rows))\n    min_col, max_col = (np.min(cols), np.max(cols))\n    height, width = l.shape\n    s_height, s_width = s.shape\n    row_offset = (height - s_height) // 2\n    col_offset = (width - s_width) // 2\n    out[min_row + row_offset:min_row + row_offset + s_height, min_col + col_offset:min_col + col_offset + s_width] = s\n    return out", "prompt": "create a copy of l, find the inner black area in l, copy the square area s to the black area in the copy of l", "subfunctions": [], "parent": "main"}, "replace_teal_pixels": {"code": "def replace_teal_pixels(o: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function replaces teal pixels in o based on their position relative to the diagonal of o.\n\n    Args:\n    - o: a numpy array representing the copy of l with the square area s copied to the black area in the middle\n\n    Returns:\n    - out: a numpy array representing the copy of l with the square area s copied to the black area in the middle and teal pixels replaced based on their position relative to the diagonal of o\n    \"\"\"\n    height, width = o.shape\n    diagonal = np.diag(np.full(height, True))\n    rows, cols = np.where((o == teal) & (diagonal == False))\n    for row, col in zip(rows, cols):\n        if row > col and row + col < height - 1:\n            o[row, col] = o[:, 0][row]\n        elif row > col and row + col > height - 1:\n            o[row, col] = o[-1, :][col]\n        elif row < col and row + col < height - 1:\n            o[row, col] = o[0, :][col]\n        elif row < col and row + col > height - 1:\n            o[row, col] = o[:, -1][row]\n    return o", "prompt": "if any teal pixel in o, if it is not in the diagonal of o, turn the color of the teal pixel, if row > col and rol + col < height - 1 to the color of left edge line, if row > col and rol + col > height - 1 to the color of bottom edge line, if row < col and rol + col < height - 1 to the color of top edge line, if row < col and rol + col > height - 1 to the color of right edge line", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    p = \"find all not black and not teal pixels\"(input_grid)\n    t = \"find all teal pixels\"(input_grid)\n    s = \"get the max and min row and col of pixels in t, return the pixels between and in this four edge\"(input_grid, t)\n    l = \"get the max and min row and col of pixels in p, return the pixels between and in this four edge\"(input_grid, p)\n    o = \"create a copy of l, find the inner black area in l, copy the square area s to the black area in the copy of l\"(s, l)\n    out = \"if any teal pixel in o, if it is not in the diagonal of o, turn the color of the teal pixel, if row > col and rol + col < height - 1 to the color of left edge line, if row > col and rol + col > height - 1 to the color of bottom edge line, if row < col and rol + col < height - 1 to the color of top edge line, if row < col and rol + col > height - 1 to the color of right edge line\"(o)\n    return out", "prompt": null, "subfunctions": ["find_non_black_teal_pixels", "find_teal_pixels", "find_smallest_area", "find_smallest_covering_area", "copy_square_to_middle", "replace_teal_pixels"], "parent": null}}, "entry": "main"}
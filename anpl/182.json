{"funs": {"divide_input": {"code": "def divide_input(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Divides the input grid by all blue rows and pixels, and returns the center grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the center grid.\n    \"\"\"\n    blue_rows = np.where(np.all(input_grid == blue, axis=1))[0]\n    blue_cols = np.where(np.all(input_grid == blue, axis=0))[0]\n    center_grid = input_grid[blue_rows[0] + 1:blue_rows[-1], blue_cols[0] + 1:blue_cols[-1]]\n    return center_grid", "prompt": "devide the input with all blue rows and pixels, remain the center grid", "subfunctions": [], "parent": "main"}, "turn_upper_left_quarter": {"code": "def turn_upper_left_quarter(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Turns non-black pixels in upper left quarter of output_grid into the color of the upper left pixel of input grid.\n\n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    upper_left_color = input_grid[0, 0]\n    rows, cols = output_grid.shape\n    for i in range(rows // 2):\n        for j in range(cols // 2):\n            if output_grid[i, j] != black:\n                output_grid[i, j] = upper_left_color\n    return output_grid", "prompt": "turn non-black pixels in upper left quarter of output_grid into the color of the upper left pixel of input grid", "subfunctions": [], "parent": "main"}, "turn_upper_right_quarter": {"code": "def turn_upper_right_quarter(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Turns non-black pixels in upper right quarter of output_grid into the color of the upper right pixel of input grid.\n\n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    upper_right_color = input_grid[0, -1]\n    rows, cols = output_grid.shape\n    for i in range(rows // 2):\n        for j in range(cols // 2, cols):\n            if output_grid[i, j] != black:\n                output_grid[i, j] = upper_right_color\n    return output_grid", "prompt": "turn non-black pixels in upper right quarter into the color of the upper right pixel of input grid", "subfunctions": [], "parent": "main"}, "turn_lower_left_quarter": {"code": "def turn_lower_left_quarter(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Turns non-black pixels in lower left quarter of output_grid into the color of the lower left pixel of input grid.\n\n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    lower_left_color = input_grid[-1, 0]\n    rows, cols = output_grid.shape\n    for i in range(rows // 2, rows):\n        for j in range(cols // 2):\n            if output_grid[i, j] != black:\n                output_grid[i, j] = lower_left_color\n    return output_grid", "prompt": "turn non-black pixels in lower left quarter into the color of the lower left pixel of input grid", "subfunctions": [], "parent": "main"}, "turn_lower_right_quarter": {"code": "def turn_lower_right_quarter(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Turns non-black pixels in lower right quarter of output_grid into the color of the lower right pixel of input grid.\n\n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    lower_right_color = input_grid[-1, -1]\n    rows, cols = output_grid.shape\n    for i in range(rows // 2, rows):\n        for j in range(cols // 2, cols):\n            if output_grid[i, j] != black:\n                output_grid[i, j] = lower_right_color\n    return output_grid", "prompt": "turn non-black pixels in lower right quarter into the color of the lower right pixel of input grid", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = \"devide the input with all blue rows and pixels, remain the center grid\"(input_grid)\n    output_grid = \"turn non-black pixels in upper left quarter of output_grid into the color of the upper left pixel of input grid\"(output_grid, input_grid)\n    output_grid = \"turn non-black pixels in upper right quarter into the color of the upper right pixel of input grid\"(output_grid, input_grid)\n    output_grid = \"turn non-black pixels in lower left quarter into the color of the lower left pixel of input grid\"(output_grid, input_grid)\n    output_grid = \"turn non-black pixels in lower right quarter into the color of the lower right pixel of input grid\"(output_grid, input_grid)\n    return output_grid", "prompt": null, "subfunctions": ["divide_input", "turn_upper_left_quarter", "turn_upper_right_quarter", "turn_lower_left_quarter", "turn_lower_right_quarter"], "parent": null}}, "entry": "main"}
{"funs": {"find_first_black_pixel": {"code": "def find_first_black_pixel(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Traverse the input grid from top to bottom, from left to right, and return the coordinates of the first black pixel (tx, ty)\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == black:\n                return (i, j)\n    return (-1, -1)", "prompt": "Traverse the inputgrid from top to bottom, from left to right, and return the coordinates of the first black pixel (tx, ty)", "subfunctions": [], "parent": "main"}, "rotate_and_subgrid": {"code": "def rotate_and_subgrid(input_grid: np.ndarray, tx: int, ty: int) -> np.ndarray:\n    \"\"\"\n    Rotate the input grid 90 degrees clockwise, and return the subgrid with (tx,ty) as the upper left corner and shape as (3,3)\n    \"\"\"\n    rotated_grid = np.rot90(input_grid)\n    subgrid = rotated_grid[tx:tx + 3, ty:ty + 3]\n    return subgrid", "prompt": "Rotate the inputgrid 90 degrees clockwise, and return the subgrid with (tx,ty) as the upper left corner and shape as (3,3)", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    tx, ty = \"Traverse the inputgrid from top to bottom, from left to right, and return the coordinates of the first black pixel (tx, ty)\"(input_grid)\n    ans_grid = \"Rotate the inputgrid 90 degrees clockwise, and return the subgrid with (tx,ty) as the upper left corner and shape as (3,3)\"(input_grid, tx, ty)\n    return ans_grid", "prompt": "In the input, you should see a n*n grid with multiple color pixels.", "subfunctions": ["find_first_black_pixel", "rotate_and_subgrid"], "parent": null}}, "entry": "main"}
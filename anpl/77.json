{"funs": {"generate_column_distances": {"code": "def generate_column_distances(output_grid: np.ndarray) -> Dict[int, int]:\n    column_distances = {}\n    for col in range(output_grid.shape[1]):\n        if red in output_grid[:, col]:\n            red_index = np.where(output_grid[:, col] == red)[0][0]\n            black_index = np.where(output_grid[:, col] == black)[0][0]\n            distance = red_index - black_index\n            column_distances[col] = distance\n    return column_distances", "prompt": " Traverse all the columns, find all the columns with red squares, calculate the distance between the first black square and the first red square and generate a dictionary (key is column number,value is distance) ", "subfunctions": [], "parent": "main"}, "move_red_squares_up_by_distance": {"code": "def move_red_squares_up_by_distance(grid: np.ndarray, column_distance: Tuple[int, int]) -> np.ndarray:\n    col, distance = column_distance\n    red_indices = np.where(grid[:, col] == red)[0]\n    for index in red_indices:\n        grid[index - distance, col] = red\n        grid[index, col] = black\n    return grid", "prompt": " move all the red squares of the input column up by the corresponding distance ", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    dict = \" Traverse all the columns, find all the columns with red squares, calculate the distance between the first black square and the first red square and generate a dictionary (key is column number,value is distance) \"(output_grid)\n    for kv in dict.items():\n        output_grid = \" move all the red squares of the input column up by the corresponding distance \"(output_grid, kv)\n    return output_grid", "prompt": null, "subfunctions": ["generate_column_distances", "move_red_squares_up_by_distance"], "parent": null}}, "entry": "main"}
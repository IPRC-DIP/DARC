{"funs": {"rotate_grid": {"code": "def rotate_grid(input_grid: np.ndarray) -> np.ndarray:\n    if input_grid.shape[0] > input_grid.shape[1]:\n        return np.rot90(input_grid)\n    return input_grid", "prompt": "anticlockwise rotate the input grid if the rows is larger than columns in input grid.", "subfunctions": [], "parent": "main"}, "find_non_black_elements": {"code": "def find_non_black_elements(input_grid: np.ndarray) -> List[Tuple[int, Tuple[int, int]]]:\n    non_black_elements = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black:\n                non_black_elements.append((input_grid[i][j], (i, j)))\n                if len(non_black_elements) == 2:\n                    return non_black_elements\n    return non_black_elements", "prompt": "find the two non black elements in input grid, return the element and position", "subfunctions": [], "parent": "main"}, "set_columns_to_color": {"code": "def set_columns_to_color(input_grid: np.ndarray, color_and_position: List[Tuple[int, Tuple[int, int]]]) -> np.ndarray:\n    for color, position in color_and_position:\n        for i in range(input_grid.shape[0]):\n            input_grid[i][position[1]] = color\n    return input_grid", "prompt": "set the columns of positions to color in input grid", "subfunctions": [], "parent": "main"}, "repeat_colors_by_distance": {"code": "def repeat_colors_by_distance(input_grid: np.ndarray, color_and_position: List[Tuple[int, Tuple[int, int]]]) -> np.ndarray:\n    first_color, second_color = (color_and_position[0][0], color_and_position[1][0])\n    distance = abs(color_and_position[0][1][1] - color_and_position[1][1][1])\n    start_col = min(color_and_position[0][1][1], color_and_position[1][1][1])\n    end_col = max(color_and_position[0][1][1], color_and_position[1][1][1])\n    for col in range(start_col, input_grid.shape[1], distance):\n        color = first_color if (col - start_col) % (2 * distance) < distance else second_color\n        for row in range(input_grid.shape[0]):\n            input_grid[row][col] = color\n    return input_grid", "prompt": "started from the first colored column to the end of the grid, interval by the distance of the two colored column, fill the column with the first color and change the color next interval ", "subfunctions": [], "parent": "main"}, "rotate_second_grid_if_needed": {"code": "def rotate_second_grid_if_needed(first_grid: np.ndarray, second_grid: np.ndarray) -> np.ndarray:\n    if first_grid.shape[0] > first_grid.shape[1]:\n        return np.rot90(second_grid)\n    return second_grid", "prompt": "there are two grid, if the rows is larger than columns in first grid, rotate the second grid, return the second grid only ", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = \"anticlockwise rotate the input grid if the rows is larger than columns in input grid.\"(input_grid)\n    color_and_position = \"find the two non black elements in input grid, return the element and position\"(output_grid)\n    output_grid = \"set the columns of positions to color in input grid\"(output_grid, color_and_position)\n    output_grid = \"started from the first colored column to the end of the grid, interval by the distance of the two colored column, fill the column with the first color and change the color next interval \"(output_grid, color_and_position)\n    output_grid = \"there are two grid, if the rows is larger than columns in first grid, rotate the second grid, return the second grid only \"(input_grid, output_grid)\n    return output_grid", "prompt": null, "subfunctions": ["rotate_grid", "find_non_black_elements", "set_columns_to_color", "repeat_colors_by_distance", "rotate_second_grid_if_needed"], "parent": null}}, "entry": "main"}
{"funs": {"is_valid_position": {"code": "def is_valid_position(input, position):\n    i, j = position\n    if input[i][j] == black:\n        return False\n    neighborhood = input[i - 1:i + 2, j - 1:j + 2]\n    return np.count_nonzero(neighborhood != black) == 2", "prompt": "if the position is not black and the number of non-black positions in its 3 by 3 neighborhood is 2", "subfunctions": [], "parent": "func1"}, "change_neighbor": {"code": "def change_neighbor(input: np.ndarray, position: Tuple[int, int]) -> np.ndarray:\n    i, j = position\n    if input[i - 1][j - 1] != black:\n        input[i + 1][j + 1] = input[i - 1][j - 1]\n    if input[i - 1][j + 1] != black:\n        input[i + 1][j - 1] = input[i - 1][j + 1]\n    if input[i + 1][j - 1] != black:\n        input[i - 1][j + 1] = input[i + 1][j - 1]\n    if input[i + 1][j + 1] != black:\n        input[i - 1][j - 1] = input[i + 1][j + 1]\n    return input", "prompt": "if the upper left corner is not black, color the lower right corner the same color; If the top right corner is not black, color the bottom left the same color; If the bottom left corner is not black, color the top right corner the same color; If the bottom right corner is not black, color the top left corner the same color.", "subfunctions": [], "parent": "func1"}, "func1": {"code": "def func1(input):\n    output = np.copy(input)\n    for i in range(1, input.shape[0] - 1):\n        for j in range(1, input.shape[1] - 1):\n            if \"if the position is not black and the number of non-black positions in its 3 by 3 neighborhood is 2\"(output, (i, j)):\n                output = \"if the upper left corner is not black, color the lower right corner the same color; If the top right corner is not black, color the bottom left the same color; If the bottom left corner is not black, color the top right corner the same color; If the bottom right corner is not black, color the top left corner the same color.\"(output, (i, j))\n    return output", "prompt": null, "subfunctions": ["is_valid_position", "change_neighbor"], "parent": "main"}, "are_arrays_equal": {"code": "def are_arrays_equal(arr1: np.ndarray, arr2: np.ndarray) -> bool:\n    return np.array_equal(arr1, arr2)", "prompt": null, "subfunctions": [], "parent": "is_converged"}, "is_converged": {"code": "def is_converged(prev_output: np.ndarray, new_output: np.ndarray) -> bool:\n    return are_arrays_equal(prev_output, new_output)", "prompt": "adjust if the two input numpy array are same", "subfunctions": ["are_arrays_equal"], "parent": "main"}, "main": {"code": "def main(input):\n    output = np.copy(input)\n    while True:\n        output1 = func1(output)\n        if \"adjust if the two input numpy array are same\"(output, output1):\n            break\n        else:\n            output = output1\n    return output", "prompt": null, "subfunctions": ["func1", "is_converged"], "parent": null}}, "entry": "main"}
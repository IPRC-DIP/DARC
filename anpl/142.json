{"funs": {"get_non_black_pattern": {"code": "def get_non_black_pattern(left_upper_square: np.ndarray) -> np.ndarray:\n    return np.where(left_upper_square != black)", "prompt": null, "subfunctions": [], "parent": "main"}, "find_same_shape_pattern": {"code": "def find_same_shape_pattern(input_grid: np.ndarray, pattern: np.ndarray) -> np.ndarray:\n    for i in range(1, input_grid.shape[0] - 2):\n        for j in range(1, input_grid.shape[1] - 2):\n            if np.array_equal(pattern, np.where(input_grid[i:i + 3, j:j + 3] != black)):\n                return input_grid[i:i + 3, j:j + 3]\n    return None", "prompt": null, "subfunctions": [], "parent": "main"}, "change_pattern_to_grey": {"code": "def change_pattern_to_grey(input_grid: np.ndarray, pattern: np.ndarray) -> np.ndarray:\n    color = pattern[pattern != black][0]\n    for i in range(input_grid.shape[0] - 2):\n        for j in range(input_grid.shape[1] - 2):\n            if np.array_equal(pattern, input_grid[i:i + 3, j:j + 3]):\n                input_grid[i:i + 3, j:j + 3][input_grid[i:i + 3, j:j + 3] == color] = grey\n    return input_grid", "prompt": null, "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    left_upper_square = input_grid[:3, :3]\n    pattern = get_non_black_pattern(left_upper_square)\n    another_pattern = find_same_shape_pattern(input_grid, pattern)\n    output_grid = input_grid.copy()\n    output_grid = change_pattern_to_grey(output_grid, another_pattern)\n    return output_grid", "prompt": null, "subfunctions": ["get_non_black_pattern", "find_same_shape_pattern", "change_pattern_to_grey"], "parent": null}}, "entry": "main"}
{"funs": {"get_adjacent_points": {"code": "def get_adjacent_points(i: int, j: int, rows: int, cols: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes in the row and column indices of a point in a grid and returns a list of tuples representing the row and column indices of its adjacent points.\n    \n    Args:\n    - i: An integer representing the row index of the point.\n    - j: An integer representing the column index of the point.\n    - rows: An integer representing the number of rows in the grid.\n    - cols: An integer representing the number of columns in the grid.\n    \n    Returns:\n    - adjacent_points: A list of tuples representing the row and column indices of the adjacent points.\n    \"\"\"\n    adjacent_points = []\n    if i > 0:\n        adjacent_points.append((i - 1, j))\n    if i < rows - 1:\n        adjacent_points.append((i + 1, j))\n    if j > 0:\n        adjacent_points.append((i, j - 1))\n    if j < cols - 1:\n        adjacent_points.append((i, j + 1))\n    return adjacent_points", "prompt": "This function takes in the row and column indices of a point in a grid and returns a list of tuples representing the row and column indices of its adjacent points.\n\nArgs:\n- i: An integer representing the row index of the point.\n- j: An integer representing the column index of the point.\n- rows: An integer representing the number of rows in the grid.\n- cols: An integer representing the number of columns in the grid.\n\nReturns:\n- adjacent_points: A list of tuples representing the row and column indices of the adjacent points.", "subfunctions": [], "parent": "process_grid"}, "process_grid": {"code": "def process_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes in a numpy array representing a grid of colors and processes it according to the following rules:\n    - For every red point in the grid, if it has green adjacent points, turn that green adjacent point to teal and turn the red point to black.\n    - Return the processed grid.\n    \n    Args:\n    - input_grid: A numpy array representing a grid of colors. Each element in the array is an integer representing a color.\n    \n    Returns:\n    - output_grid: A numpy array representing the processed grid of colors.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] == red:\n                adjacent_points = \"This function takes in the row and column indices of a point in a grid and returns a list of tuples representing the row and column indices of its adjacent points.\n\nArgs:\n- i: An integer representing the row index of the point.\n- j: An integer representing the column index of the point.\n- rows: An integer representing the number of rows in the grid.\n- cols: An integer representing the number of columns in the grid.\n\nReturns:\n- adjacent_points: A list of tuples representing the row and column indices of the adjacent points.\"(i, j, rows, cols)\n                for point in adjacent_points:\n                    if input_grid[point[0]][point[1]] == green:\n                        output_grid[point[0]][point[1]] = teal\n                        output_grid[i][j] = black\n    return output_grid", "prompt": "For every red point in grid, if it has green adjacent points , trun that green adjacent point to teal, turn red point to black", "subfunctions": ["get_adjacent_points"], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = \"For every red point in grid, if it has green adjacent points , trun that green adjacent point to teal, turn red point to black\"(input_grid)\n    return output_grid", "prompt": null, "subfunctions": ["process_grid"], "parent": null}}, "entry": "main"}
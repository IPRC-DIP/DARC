{"funs": {"get_input_matrix_height": {"code": "def get_input_matrix_height(input_grid: np.ndarray) -> int:\n    return input_grid.shape[0]", "prompt": "Obtain the height of the input image matrix, denoted as d (which is also equal to the width)", "subfunctions": [], "parent": "main"}, "rotate_and_stack": {"code": "def rotate_and_stack(input_grid: np.ndarray) -> np.ndarray:\n    input_grid1 = np.rot90(input_grid)\n    input_grid2 = np.rot90(input_grid1)\n    input_grid3 = np.rot90(input_grid2)\n    output_grid = np.add(np.add(np.add(input_grid, input_grid1), input_grid2), input_grid3)\n    return output_grid", "prompt": null, "subfunctions": [], "parent": "main"}, "assign_colors_to_pixels1": {"code": "def assign_colors_to_pixels1(input_grid: np.ndarray, d: int) -> np.ndarray:\n    for i in range(int(d / 2)):\n        c = input_grid[i][i + 2]\n        for j in range(i + 4, d, 2):\n            if input_grid[i][j] != black:\n                break\n            input_grid[i][j] = c\n    return input_grid", "prompt": "Function name is assign_colors_to_pixels1. Traverse from row 0 to row int(d/2). For each i-th row, visit coordinate (i,i+2) and record its color as c. Then, for the subsequent pixels in that row, assign pixels with even distances to c (coordinates are (i,i+4), (i,i+6), (i,i+8), and so on), until encountering a non-black pixel.", "subfunctions": [], "parent": "main"}, "assign_colors_to_pixels2": {"code": "def assign_colors_to_pixels2(input_grid: np.ndarray, d: int) -> np.ndarray:\n    for i in range(int(d / 2), d):\n        c = input_grid[i][i - 2]\n        for j in range(i - 4, -1, -2):\n            if input_grid[i][j] != black:\n                break\n            input_grid[i][j] = c\n    return input_grid", "prompt": "Function name is assign_colors_to_pixels2. Traverse from row int(d/2) to row d. For each i-th row, visit coordinate (i,i-2) and record its color as c. Then, for the previous pixels in that row, assign pixels with even distances to c (coordinates are (i,i-4), (i,i-6), (i,i-8), and so on), until encountering a non-black pixel.", "subfunctions": [], "parent": "main"}, "create_output_grid": {"code": "def create_output_grid(input_grid: np.ndarray) -> np.ndarray:\n    input_grid4 = np.rot90(input_grid, k=3)\n    output_grid = np.zeros_like(input_grid)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black:\n                output_grid[i][j] = input_grid[i][j]\n            else:\n                output_grid[i][j] = input_grid4[i][j]\n    return output_grid", "prompt": "Rotate the modified input_grid by 90 degrees to obtain input_grid4, then create an all-black matrix output_grid of the same size as input_grid. Traverse each pixel in output_grid and assign its value to the corresponding value in input_grid if the value at the corresponding position in input_grid is not 0, otherwise assign its value to the corresponding value in input_grid4.", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    d = \"Obtain the height of the input image matrix, denoted as d (which is also equal to the width)\"(input_grid)\n    input_grid = rotate_and_stack(input_grid)\n    input_grid = \"Function name is assign_colors_to_pixels1. Traverse from row 0 to row int(d/2). For each i-th row, visit coordinate (i,i+2) and record its color as c. Then, for the subsequent pixels in that row, assign pixels with even distances to c (coordinates are (i,i+4), (i,i+6), (i,i+8), and so on), until encountering a non-black pixel.\"(input_grid, d)\n    input_grid = \"Function name is assign_colors_to_pixels2. Traverse from row int(d/2) to row d. For each i-th row, visit coordinate (i,i-2) and record its color as c. Then, for the previous pixels in that row, assign pixels with even distances to c (coordinates are (i,i-4), (i,i-6), (i,i-8), and so on), until encountering a non-black pixel.\"(input_grid, d)\n    output_grid = \"Rotate the modified input_grid by 90 degrees to obtain input_grid4, then create an all-black matrix output_grid of the same size as input_grid. Traverse each pixel in output_grid and assign its value to the corresponding value in input_grid if the value at the corresponding position in input_grid is not 0, otherwise assign its value to the corresponding value in input_grid4.\"(input_grid)\n    return output_grid", "prompt": null, "subfunctions": ["get_input_matrix_height", "rotate_and_stack", "assign_colors_to_pixels1", "assign_colors_to_pixels2", "create_output_grid"], "parent": null}}, "entry": "main"}
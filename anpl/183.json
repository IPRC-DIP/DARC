{"funs": {"find_all_black_rows_and_columns": {"code": "def find_all_black_rows_and_columns(input_grid: np.ndarray) -> Tuple[List[int], List[int]]:\n    rows, columns = (np.where(np.all(input_grid == black, axis=1)), np.where(np.all(input_grid == black, axis=0)))\n    return (rows[0].tolist(), columns[0].tolist())", "prompt": "find all rows and colomns with all black pixels", "subfunctions": [], "parent": "main"}, "add_border": {"code": "def add_border(rows: List[int], columns: List[int], input_grid: np.ndarray) -> Tuple[List[int], List[int]]:\n    max_row, max_col = input_grid.shape\n    rows = [0] + [r + 1 for r in rows] + [max_row]\n    columns = [0] + [c + 1 for c in columns] + [max_col]\n    return (rows, columns)", "prompt": "add 0 at the start of rows and colomns, add the last row numbers of input_grid at the end of rows, add the biggest colomn numbers of input_grid at the end of colomns", "subfunctions": [], "parent": "main"}, "divide_subgrids": {"code": "def divide_subgrids(rows: List[int], columns: List[int], input_grid: np.ndarray) -> List[np.ndarray]:\n    sub_grids = []\n    for i in range(len(rows) - 1):\n        for j in range(len(columns) - 1):\n            sub_grid = input_grid[rows[i]:rows[i + 1], columns[j]:columns[j + 1]]\n            sub_grids.append(sub_grid)\n    return sub_grids", "prompt": "divide the input grid in to several subgrids by the rows and colomns", "subfunctions": [], "parent": "main"}, "create_output_grid": {"code": "def create_output_grid(rows: List[int], columns: List[int]) -> np.ndarray:\n    return np.zeros((len(rows) - 1, len(columns) - 1), dtype=int)", "prompt": "create the output grid with row number 1 bigger than number of rows, colomn number 1 bigger than number of colomns", "subfunctions": [], "parent": "main"}, "fill_subgrid_colors": {"code": "def fill_subgrid_colors(sub_grids: List[np.ndarray], output_grid: np.ndarray) -> np.ndarray:\n    for i, sub_grid in enumerate(sub_grids):\n        unique, counts = np.unique(sub_grid, return_counts=True)\n        color_counts = dict(zip(unique, counts))\n        if black in color_counts:\n            del color_counts[black]\n        if color_counts:\n            max_color = max(color_counts, key=color_counts.get)\n            output_grid[i // output_grid.shape[1], i % output_grid.shape[1]] = max_color\n    return output_grid", "prompt": "find the kind of colors in the subgrids, and fill these colors in the output grid", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    rows, colomns = \"find all rows and colomns with all black pixels\"(input_grid)\n    rows, colomns = \"add 0 at the start of rows and colomns, add the last row numbers of input_grid at the end of rows, add the biggest colomn numbers of input_grid at the end of colomns\"(rows, colomns, input_grid)\n    sub_grids = \"divide the input grid in to several subgrids by the rows and colomns\"(rows, colomns, input_grid)\n    output_grid = \"create the output grid with row number 1 bigger than number of rows, colomn number 1 bigger than number of colomns\"(rows, colomns)\n    output_grid = \"find the kind of colors in the subgrids, and fill these colors in the output grid\"(sub_grids, output_grid)\n    return output_grid", "prompt": null, "subfunctions": ["find_all_black_rows_and_columns", "add_border", "divide_subgrids", "create_output_grid", "fill_subgrid_colors"], "parent": null}}, "entry": "main"}
{"funs": {"dfs": {"code": "def dfs(i: int, j: int, grid: np.ndarray, visited: np.ndarray, pattern: List[Tuple[int, int]]):\n    \"\"\"\n    A helper function for find_green_patterns that performs a depth-first search to find all connected pixels of the same color.\n    \"\"\"\n    visited[i][j] = True\n    pattern.append((i, j))\n    for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n        if 0 <= x < grid.shape[0] and 0 <= y < grid.shape[1] and (grid[x][y] == green) and (not visited[x][y]):\n            dfs(x, y, grid, visited, pattern)", "prompt": "A helper function for find_green_patterns that performs a depth-first search to find all connected pixels of the same color.", "subfunctions": [], "parent": "find_green_patterns"}, "find_green_patterns": {"code": "def find_green_patterns(grid: np.ndarray) -> List[List[Tuple[int, int]]]:\n    \"\"\"\n    Given a 2D numpy array representing a grid of pixels, this function returns a list of all green patterns.\n    A pattern is defined as a set of connected pixels of the same color.\n    Each pattern is represented as a list of tuples, where each tuple contains the row and column indices of a pixel in the pattern.\n    \"\"\"\n    green_patterns = []\n    visited = np.zeros_like(grid, dtype=bool)\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if grid[i][j] == green and (not visited[i][j]):\n                pattern = []\n                \"A helper function for find_green_patterns that performs a depth-first search to find all connected pixels of the same color.\"(i, j, grid, visited, pattern)\n                green_patterns.append(pattern)\n    return green_patterns", "prompt": "find all green patterns, a pattern is some connected pixels in same color", "subfunctions": ["dfs"], "parent": "main"}, "count_90_degree_sides": {"code": "def count_90_degree_sides(patterns: List[List[Tuple[int, int]]], grid: np.ndarray) -> Dict[int, int]:\n    \"\"\"\n    For every pattern in patterns, count how many 90 degree sides in it by traversing pixels in the pattern,\n    a 90 degree sides means if 2 adjacent neighbors of a pixels are both in the pattern but the pixel along the diagonal direction and adjacent to the 2 neighbors is not in the pattern,\n    for example, the left and top is in pattern and the left top pixel along the diagonal direction is not.\n    Returns a dictionary where the keys are the indices of the patterns and the values are the number of 90 degree sides in the pattern.\n    \"\"\"\n    sides_count = {}\n    for i, pattern in enumerate(patterns):\n        count = 0\n        for x, y in pattern:\n            if x > 0 and y > 0 and (x < grid.shape[0] - 1) and (y < grid.shape[1] - 1):\n                if (x - 1, y) in pattern and (x, y - 1) in pattern and ((x - 1, y - 1) not in pattern):\n                    count += 1\n                if (x - 1, y) in pattern and (x, y + 1) in pattern and ((x - 1, y + 1) not in pattern):\n                    count += 1\n                if (x + 1, y) in pattern and (x, y - 1) in pattern and ((x + 1, y - 1) not in pattern):\n                    count += 1\n                if (x + 1, y) in pattern and (x, y + 1) in pattern and ((x + 1, y + 1) not in pattern):\n                    count += 1\n        sides_count[i] = count\n    return sides_count", "prompt": "For every pattern in patterns, count how many 90 degree sides in it by traversing pixels in the pattern, a 90 degree sides means if 2 adjacent neighbors of a pixels are both in the pattern but the pixel along the diagonal direction and adjacent to the 2 neighbors is not in the pattern, for example, the left and top is in pattern and the left top pixel along the diagonal direction is not.", "subfunctions": [], "parent": "main"}, "color_patterns": {"code": "def color_patterns(p: List[List[Tuple[int, int]]], record: Dict[int, int], grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a list of patterns, a dictionary of their 90 degree sides count, and a 2D numpy array representing a grid of pixels,\n    this function colors the patterns based on their 90 degree sides count and returns the updated grid.\n    A pattern with 1 90 degree side is colored blue, a pattern with 2 90 degree sides is colored pink, and a pattern with 3 90 degree sides is colored red.\n    \"\"\"\n    for i, pattern in enumerate(p):\n        if record[i] == 1:\n            color = blue\n        elif record[i] == 2:\n            color = pink\n        elif record[i] == 3:\n            color = red\n        else:\n            color = green\n        for x, y in pattern:\n            grid[x][y] = color\n    return grid", "prompt": "For every pattern in p, if its record is 1 turn it to blue, if 2 to pink, if 3 to red. return the grid", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    p = \"find all green patterns, a pattern is some connected pixels in same color\"(input_grid)\n    record = \"For every pattern in patterns, count how many 90 degree sides in it by traversing pixels in the pattern, a 90 degree sides means if 2 adjacent neighbors of a pixels are both in the pattern but the pixel along the diagonal direction and adjacent to the 2 neighbors is not in the pattern, for example, the left and top is in pattern and the left top pixel along the diagonal direction is not.\"(p, input_grid)\n    out = \"For every pattern in p, if its record is 1 turn it to blue, if 2 to pink, if 3 to red. return the grid\"(p, record, input_grid)\n    return out", "prompt": null, "subfunctions": ["find_green_patterns", "count_90_degree_sides", "color_patterns"], "parent": null}}, "entry": "main"}
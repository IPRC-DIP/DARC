{"funs": {"divide_grid_by_red_columns": {"code": "def divide_grid_by_red_columns(grid: np.ndarray) -> List[np.ndarray]:\n    divided_grids = []\n    start_col = 0\n    for j in range(grid.shape[1]):\n        if np.all(grid[:, j] == red):\n            divided_grids.append(grid[:, start_col:j])\n            start_col = j + 1\n    divided_grids.append(grid[:, start_col:])\n    return divided_grids[:-1][::-1]", "prompt": "return the divided grids by the red columns(the divided grid don't contain the dividing columns)", "subfunctions": [], "parent": "main"}, "copy_non_black_pixels": {"code": "def copy_non_black_pixels(output_grid: np.ndarray, grid: np.ndarray) -> np.ndarray:\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if grid[i, j] != black:\n                output_grid[i, j] = grid[i, j]\n    return output_grid", "prompt": "copy the non-black pixels in the grid to the output_grid", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    input_grid = np.concatenate((input_grid, np.array([[2], [2], [2], [2]])), axis=1)\n    divided_grids = \"return the divided grids by the red columns(the divided grid don't contain the dividing columns)\"(input_grid)\n    output_grid = np.zeros((4, 4))\n    for grid in divided_grids:\n        output_grid = \"copy the non-black pixels in the grid to the output_grid\"(output_grid, grid)\n    return output_grid", "prompt": null, "subfunctions": ["divide_grid_by_red_columns", "copy_non_black_pixels"], "parent": null}}, "entry": "main"}
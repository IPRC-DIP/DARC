{"funs": {"has_black_pixel": {"code": "def has_black_pixel(grid: np.ndarray) -> bool:\n    return np.any(grid == black)", "prompt": "whether there is black pixel in the grid", "subfunctions": [], "parent": "main"}, "find_black_pixel_locations": {"code": "def find_black_pixel_locations(grid: np.ndarray) -> Tuple:\n    return np.where(grid == black)", "prompt": "find the location of all black pixels", "subfunctions": [], "parent": "main"}, "replace_black_pixel_with_neighbour_color": {"code": "def replace_black_pixel_with_neighbour_color(grid: np.ndarray, locs: Tuple) -> np.ndarray:\n    for i in range(len(locs[0])):\n        row, col = (locs[0][i], locs[1][i])\n        if row < grid.shape[0] - 1 and col > 0 and (grid[row + 1][col - 1] != black):\n            grid[row][col] = grid[row + 1][col - 1]\n        elif row > 0 and col < grid.shape[1] - 1 and (grid[row - 1][col + 1] != black):\n            grid[row][col] = grid[row - 1][col + 1]\n    return grid", "prompt": "for each black pixel, if it has a not black pixel neighbour at its bottom left or top right, change the black pixel to the color of this neighbour", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = input_grid\n    while \"whether there is black pixel in the grid\"(output_grid):\n        locs = \"find the location of all black pixels\"(output_grid)\n        output_grid = \"for each black pixel, if it has a not black pixel neighbour at its bottom left or top right, change the black pixel to the color of this neighbour\"(output_grid, locs)\n    return output_grid", "prompt": null, "subfunctions": ["has_black_pixel", "find_black_pixel_locations", "replace_black_pixel_with_neighbour_color"], "parent": null}}, "entry": "main"}
{"funs": {"find_different_color_neighbours": {"code": "def find_different_color_neighbours(grid: np.ndarray, i: int, j: int) -> bool:\n    neighbours = grid[i - 1:i + 2, j - 1:j + 2]\n    unique, counts = np.unique(neighbours, return_counts=True)\n    for color, count in zip(unique, counts):\n        if color != black and color != grid[i][j] and (count >= 2):\n            return True\n    return False", "prompt": null, "subfunctions": [], "parent": "find_patterns"}, "find_patterns": {"code": "def find_patterns(grid: np.ndarray) -> List[np.ndarray]:\n    patterns = []\n    for i in range(1, grid.shape[0] - 1):\n        for j in range(1, grid.shape[1] - 1):\n            if grid[i][j] != black:\n                if find_different_color_neighbours(grid, i, j):\n                    patterns.append(grid[i - 1:i + 2, j - 1:j + 2])\n    return patterns", "prompt": null, "subfunctions": ["find_different_color_neighbours"], "parent": "main"}, "find_all_colors": {"code": "def find_all_colors(grid: np.ndarray) -> List[int]:\n    return [color for color in np.unique(grid) if color != black]", "prompt": "find all colors (non black) in grid", "subfunctions": [], "parent": "compare_grids"}, "same_color_positions": {"code": "def same_color_positions(grid1: np.ndarray, grid2: np.ndarray, color: int) -> bool:\n    return np.array_equal(np.where(grid1 == color), np.where(grid2 == color))", "prompt": "the positions of this color in two different grids are all the same", "subfunctions": [], "parent": "compare_grids"}, "compare_grids": {"code": "def compare_grids(grid1, grid2):\n    colors = \"find all colors (non black) in grid\"(grid2)\n    for color in colors:\n        if \"the positions of this color in two different grids are all the same\"(grid1, grid2, color):\n            return True\n    return False", "prompt": null, "subfunctions": ["find_all_colors", "same_color_positions"], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    patterns = find_patterns(input_grid)\n    output_grid = input_grid.copy()\n    for i in range(1, input_grid.shape[0] - 1):\n        for j in range(1, input_grid.shape[1] - 1):\n            for pattern in patterns:\n                if compare_grids(output_grid[i - 1:i + 2, j - 1:j + 2], pattern):\n                    output_grid[i - 1:i + 2, j - 1:j + 2] = pattern\n                    break\n    return output_grid", "prompt": null, "subfunctions": ["find_patterns", "compare_grids"], "parent": null}}, "entry": "main"}
{"funs": {"find_position_with_three_different_colors": {"code": "def find_position_with_three_different_colors(input_grid: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Traverse the input, return the position, the four connected positions of which have three different colors and this position is not black\n    \n    Args:\n    input_grid: A list of lists representing the grid of colors\n    \n    Returns:\n    A tuple containing the row and column index of the position\n    \"\"\"\n    rows, cols = (len(input_grid), len(input_grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] != black:\n                colors = set()\n                if i > 0:\n                    colors.add(input_grid[i - 1][j])\n                if i < rows - 1:\n                    colors.add(input_grid[i + 1][j])\n                if j > 0:\n                    colors.add(input_grid[i][j - 1])\n                if j < cols - 1:\n                    colors.add(input_grid[i][j + 1])\n                if len(colors) == 3:\n                    return (i, j)\n    return None", "prompt": "traverse the input, return the position, the four connected positions of which have three different colors and this position is not black", "subfunctions": [], "parent": "main"}, "black_positions_with_two_black_neighbors": {"code": "def black_positions_with_two_black_neighbors(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Traverse the input, black the position, two opposite connected positions of which are black\n    \n    Args:\n    input_grid: A list of lists representing the grid of colors\n    \n    Returns:\n    A list of lists with the updated grid of colors\n    \"\"\"\n    rows, cols = (len(input_grid), len(input_grid[0]))\n    output = np.copy(input_grid)\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0 and i < rows - 1 and (j > 0) and (j < cols - 1):\n                if input_grid[i][j] != black and input_grid[i - 1][j] == black and (input_grid[i + 1][j] == black):\n                    output[i][j] = black\n                elif input_grid[i][j] != black and input_grid[i][j - 1] == black and (input_grid[i][j + 1] == black):\n                    output[i][j] = black\n    return output", "prompt": "traverse the input, black the position, two opposite connected positions of which are black", "subfunctions": [], "parent": "main"}, "get_rectangle_coordinates": {"code": "def get_rectangle_coordinates(input_grid: List[List[int]], color: int) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Traverse the input, return the top-left and bottom-right coordinates of the rectangle corresponding to the color\n    \n    Args:\n    input_grid: A list of lists representing the grid of colors\n    color: An integer representing the color of the rectangle\n    \n    Returns:\n    A tuple containing the top-left and bottom-right coordinates of the rectangle\n    \"\"\"\n    rows, cols = (len(input_grid), len(input_grid[0]))\n    top_left = None\n    bottom_right = None\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] == color:\n                if top_left is None:\n                    top_left = (i, j)\n                else:\n                    top_left = (min(top_left[0], i), min(top_left[1], j))\n                if bottom_right is None:\n                    bottom_right = (i, j)\n                else:\n                    bottom_right = (max(bottom_right[0], i), max(bottom_right[1], j))\n    return (top_left, bottom_right)", "prompt": "Returns the top-left and bottom-right coordinates of the rectangle corresponding to the color", "subfunctions": [], "parent": "move_rectangle_to_cover_flag"}, "get_direction_and_steps": {"code": "def get_direction_and_steps(rectangle_positions: Tuple[Tuple[int, int], Tuple[int, int]], flag_position: Tuple[int, int]) -> Tuple[str, int]:\n    \"\"\"\n    Given the top-left and bottom-right coordinates of a rectangle and the position of a flag, \n    determine the direction and number of steps needed to move the rectangle to cover the flag.\n    \n    Args:\n    rectangle_positions: A tuple containing the top-left and bottom-right coordinates of the rectangle\n    flag_position: A tuple containing the row and column index of the flag\n    \n    Returns:\n    A tuple containing the direction ('up', 'down', 'left', or 'right') and number of steps needed to move the rectangle\n    \"\"\"\n    top_left, bottom_right = rectangle_positions\n    flag_row, flag_col = flag_position\n    if flag_row < top_left[0]:\n        direction = 'up'\n        steps = top_left[0] - flag_row\n    elif flag_row > bottom_right[0]:\n        direction = 'down'\n        steps = flag_row - bottom_right[0]\n    elif flag_col < top_left[1]:\n        direction = 'left'\n        steps = top_left[1] - flag_col\n    else:\n        direction = 'right'\n        steps = flag_col - bottom_right[1]\n    return (direction, steps)", "prompt": "According to the rectangular coordinates and the position of the flag, decide the direction and the moving steps of movement", "subfunctions": [], "parent": "move_rectangle_to_cover_flag"}, "move_rectangle": {"code": "def move_rectangle(rectangle_positions: Tuple[Tuple[int, int], Tuple[int, int]], direction: str, steps: int) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Given the top-left and bottom-right coordinates of a rectangle, the direction of movement, and the number of steps,\n    move the rectangle accordingly and return its new coordinates.\n    \n    Args:\n    rectangle_positions: A tuple containing the top-left and bottom-right coordinates of the rectangle\n    direction: A string representing the direction of movement ('up', 'down', 'left', or 'right')\n    steps: An integer representing the number of steps to move the rectangle\n    \n    Returns:\n    A tuple containing the top-left and bottom-right coordinates of the rectangle after movement\n    \"\"\"\n    top_left, bottom_right = rectangle_positions\n    if direction == 'up':\n        top_left = (top_left[0] - steps, top_left[1])\n        bottom_right = (bottom_right[0] - steps, bottom_right[1])\n    elif direction == 'down':\n        top_left = (top_left[0] + steps, top_left[1])\n        bottom_right = (bottom_right[0] + steps, bottom_right[1])\n    elif direction == 'left':\n        top_left = (top_left[0], top_left[1] - steps)\n        bottom_right = (bottom_right[0], bottom_right[1] - steps)\n    else:\n        top_left = (top_left[0], top_left[1] + steps)\n        bottom_right = (bottom_right[0], bottom_right[1] + steps)\n    return (top_left, bottom_right)", "prompt": "Move the rectangle according to its coordinates, direction of movement, and step size", "subfunctions": [], "parent": "move_rectangle_to_cover_flag"}, "move_rectangle_to_cover_flag": {"code": "def move_rectangle_to_cover_flag(input, color, flag):\n    positions = \"Returns the top-left and bottom-right coordinates of the rectangle corresponding to the color\"(input, color)\n    direction, steps = \"According to the rectangular coordinates and the position of the flag, decide the direction and the moving steps of movement\"(positions, flag)\n    output_positions = \"Move the rectangle according to its coordinates, direction of movement, and step size\"(positions, direction, steps)\n    output = np.copy(input)\n    output[positions[0][0]:positions[1][0] + 1, positions[0][1]:positions[1][1] + 1] = black\n    output[output_positions[0][0]:output_positions[1][0] + 1, output_positions[0][1]:output_positions[1][1] + 1] = color\n    return output", "prompt": null, "subfunctions": ["get_rectangle_coordinates", "get_direction_and_steps", "move_rectangle"], "parent": "main"}, "main": {"code": "def main(input_grid):\n    flag = \"traverse the input, return the position, the four connected positions of which have three different colors and this position is not black\"(input_grid)\n    color = input_grid[flag]\n    output = np.copy(input_grid)\n    output = \"traverse the input, black the position, two opposite connected positions of which are black\"(output)\n    output = move_rectangle_to_cover_flag(output, color, flag)\n    return output", "prompt": null, "subfunctions": ["find_position_with_three_different_colors", "black_positions_with_two_black_neighbors", "move_rectangle_to_cover_flag"], "parent": null}}, "entry": "main"}
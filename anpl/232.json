{"funs": {"get_coordinates": {"code": "def get_coordinates(grid: np.ndarray) -> List[Tuple[int, int]]:\n    coordinates = []\n    for i in range(grid.shape[0] - 2):\n        for j in range(grid.shape[1] - 2):\n            coordinates.append((i, j))\n    return coordinates", "prompt": "return all left top coordinates of 3x3 grids in the grid", "subfunctions": [], "parent": "main"}, "find_two_color_grids": {"code": "def find_two_color_grids(coordinates: List[Tuple[int, int]], grid: np.ndarray) -> List[Tuple[int, int]]:\n    two_color_grids = []\n    for i, j in coordinates:\n        square = grid[i:i + 3, j:j + 3]\n        unique_colors = np.unique(square)\n        if len(unique_colors) == 2 and black not in unique_colors:\n            two_color_grids.append((i, j))\n    return two_color_grids", "prompt": "find 3x3 grids which only has only two color, and none of them is black", "subfunctions": [], "parent": "main"}, "extract_squares": {"code": "def extract_squares(grid, coordinates):\n    return [grid[x:x + 3, y:y + 3].copy() for x, y in coordinates]", "prompt": null, "subfunctions": [], "parent": "main"}, "paint_black_3x3": {"code": "def paint_black_3x3(grid: np.ndarray, coordinates: List[Tuple[int, int]]) -> np.ndarray:\n    for i, j in coordinates:\n        grid[i:i + 3, j:j + 3] = black\n    return grid", "prompt": "paint 3x3 grid to black according to the list of coordinates", "subfunctions": [], "parent": "main"}, "find_red_shape": {"code": "def find_red_shape(grid: np.ndarray) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    red_indices = np.where(grid == red)\n    top_left = (np.min(red_indices[0]), np.min(red_indices[1]))\n    bottom_right = (np.max(red_indices[0]), np.max(red_indices[1]))\n    return (top_left, bottom_right)", "prompt": "find the red shape in the grid", "subfunctions": [], "parent": "main"}, "extract_red_shape": {"code": "def extract_red_shape(grid: np.ndarray, top_left: Tuple[int, int], bottom_right: Tuple[int, int]) -> np.ndarray:\n    return grid[top_left[0]:bottom_right[0] + 1, top_left[1]:bottom_right[1] + 1]", "prompt": "extract red shape according to the top_left and bottom_right coordinate", "subfunctions": [], "parent": "main"}, "have_other_colors": {"code": "def have_other_colors(square: np.ndarray) -> bool:\n    unique_colors = np.unique(square)\n    if len(unique_colors) == 2 and black in unique_colors and (red in unique_colors):\n        return False\n    return True", "prompt": null, "subfunctions": [], "parent": "match_and_color"}, "rotate_square": {"code": "def rotate_square(square: np.ndarray) -> List[np.ndarray]:\n    rotated_squares = []\n    for i in range(4):\n        rotated_squares.append(np.rot90(square, i))\n    return rotated_squares", "prompt": "rotate the square 4 times and return a list", "subfunctions": [], "parent": "match_and_color"}, "match": {"code": "def match(grid1: np.ndarray, grid2: np.ndarray) -> bool:\n    for i in range(grid1.shape[0]):\n        for j in range(grid1.shape[1]):\n            if grid1[i][j] == red and grid2[i][j] == red:\n                return False\n            elif grid1[i][j] == black and grid2[i][j] != red:\n                return False\n    return True", "prompt": "for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false", "subfunctions": [], "parent": "match_and_color"}, "match_and_color": {"code": "def match_and_color(grid: np.ndarray, i: int, j: int, square: np.ndarray):\n    square_to_match = grid[i:i + 3, j:j + 3]\n    if have_other_colors(square_to_match):\n        return\n    rotated_squares = \"rotate the square 4 times and return a list\"(square)\n    for rotated_square in rotated_squares:\n        if \"for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false\"(square_to_match, rotated_square):\n            grid[i:i + 3, j:j + 3] = rotated_square\n            return", "prompt": null, "subfunctions": ["have_other_colors", "rotate_square", "match"], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    coordinates = \"return all left top coordinates of 3x3 grids in the grid\"(input_grid)\n    squares_coordinates = \"find 3x3 grids which only has only two color, and none of them is black\"(coordinates, input_grid)\n    squares = extract_squares(input_grid, squares_coordinates)\n    input_grid = \"paint 3x3 grid to black according to the list of coordinates\"(input_grid, squares_coordinates)\n    top_left, bottom_right = \"find the red shape in the grid\"(input_grid)\n    output_grid = \"extract red shape according to the top_left and bottom_right coordinate\"(input_grid, top_left, bottom_right)\n    for x, y in \"return all left top coordinates of 3x3 grids in the grid\"(output_grid):\n        for square in squares:\n            match_and_color(output_grid, x, y, square)\n    return output_grid", "prompt": null, "subfunctions": ["get_coordinates", "find_two_color_grids", "extract_squares", "paint_black_3x3", "find_red_shape", "extract_red_shape", "match_and_color"], "parent": null}}, "entry": "main"}
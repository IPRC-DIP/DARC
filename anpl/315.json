{"funs": {"get_column_colors": {"code": "def get_column_colors(grid: np.ndarray) -> List[int]:\n    \"\"\"\n    Traverse each column, if there is a non-black pixel in this column, add the color of the pixel to the return list.\n    After the traversal is complete, return the answer list.\n    \"\"\"\n    color_list = []\n    for col in range(grid.shape[1]):\n        for row in range(grid.shape[0]):\n            if grid[row][col] != black:\n                color_list.append(grid[row][col])\n                break\n    return color_list", "prompt": "Traverse each column, if there is a non-black pixel in this column, add the color of the pixel to the return list. After the traversal is complete, return the answer list", "subfunctions": [], "parent": "main"}, "arrange_pixels": {"code": "def arrange_pixels(color_list: List[int]) -> np.ndarray:\n    \"\"\"\n    Given a list of colors, arrange them in a 3x3 grid in order and return the resulting grid.\n    \"\"\"\n    ans_grid = np.zeros((3, 3), dtype=int)\n    for i in range(9):\n        ans_grid[i // 3][i % 3] = color_list[i]\n    return ans_grid", "prompt": "Arrange the pixels in the color_list in order in the 3*3 grid. After the arrangement is completed,  return to the grid", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    color_list = \"Traverse each column, if there is a non-black pixel in this column, add the color of the pixel to the return list. After the traversal is complete, return the answer list\"(input_grid)\n    ans_grid = \"Arrange the pixels in the color_list in order in the 3*3 grid. After the arrangement is completed,  return to the grid\"(color_list)\n    ans_grid[1, :] = ans_grid[1, ::-1]\n    return ans_grid", "prompt": "In the input, you should see a n*n grid with multiple color pixels.", "subfunctions": ["get_column_colors", "arrange_pixels"], "parent": null}}, "entry": "main"}
{"funs": {"blacken_teal_pixels": {"code": "def blacken_teal_pixels(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Generate a new grid, exactly the same as input_grid. Blacken all the teal pixels.\n    \"\"\"\n    return np.where(input_grid == teal, black, input_grid)", "prompt": "Generate a new grid, exactly the same as input_grid. Blacken all the teal pixels", "subfunctions": [], "parent": "main"}, "find_bounding_box": {"code": "def find_bounding_box(grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Define four variables (minx, miny, maxx, maxy) as the smallest x, the smallest y, the largest x, and the largest y. \n    Traverse all the pixels in the new grid, if a pixel (x, y) is not black, use the pixel to update the above four variables\n    \"\"\"\n    minx, miny, maxx, maxy = (float('inf'), float('inf'), -float('inf'), -float('inf'))\n    for x in range(grid.shape[0]):\n        for y in range(grid.shape[1]):\n            if grid[x, y] != black:\n                minx = min(minx, x)\n                miny = min(miny, y)\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n    return (minx, miny, maxx, maxy)", "prompt": "Define four variables (minx, miny, maxx, maxy) as the smallest x, the smallest y, the largest x, and the largest y. Traverse all the pixels in the new grid, if a pixel (x, y) is not black, use the pixel to update the above four variables", "subfunctions": [], "parent": "main"}, "extract_subgrid": {"code": "def extract_subgrid(grid: np.ndarray, minx: int, miny: int, maxx: int, maxy: int) -> np.ndarray:\n    \"\"\"\n    Extract the subgrid with (minx, miny) as the upper left corner and (maxx, maxy) as the lower right corner, and return the grid\n    \"\"\"\n    return grid[minx:maxx + 1, miny:maxy + 1]", "prompt": "Extract the subgrid with (minx, miny) as the upper left corner and (maxx, maxy) as the lower right corner, and return the grid", "subfunctions": [], "parent": "main"}, "generate_teal_mask": {"code": "def generate_teal_mask(target_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Generate a new grid with the same size as the target_grid. If the pixel in the subgrid is non-black, the value in the new grid is teal; otherwise, it is black\n    \"\"\"\n    return np.where(target_grid != black, teal, black)", "prompt": "Generate a new grid with the same size as the target_grid. If the pixel in the subgrid is non-black, the value in the new grid is teal; otherwise, it is black", "subfunctions": [], "parent": "main"}, "overwrite_pixels": {"code": "def overwrite_pixels(input_grid: np.ndarray, target_grid: np.ndarray, mask_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Traverse all the elements in the input_grid, match each pixel with a grid same as mask_grid, \n    if the current pixel is matched, overwrite the position with a grid same as target_grid\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if np.array_equal(input_grid[i:i + mask_grid.shape[0], j:j + mask_grid.shape[1]], mask_grid):\n                input_grid[i:i + target_grid.shape[0], j:j + target_grid.shape[1]] = target_grid\n    return input_grid", "prompt": "Traverse all the elements in the inputgrid, match each pixel with a grid same as mask_grid, if the current pixel is matched, overwrite the position with a grid same as target_grid", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    ans_grid = \"Generate a new grid, exactly the same as input_grid. Blacken all the teal pixels\"(input_grid)\n    minx, miny, maxx, maxy = \"Define four variables (minx, miny, maxx, maxy) as the smallest x, the smallest y, the largest x, and the largest y. Traverse all the pixels in the new grid, if a pixel (x, y) is not black, use the pixel to update the above four variables\"(ans_grid)\n    target_grid = \"Extract the subgrid with (minx, miny) as the upper left corner and (maxx, maxy) as the lower right corner, and return the grid\"(ans_grid, minx, miny, maxx, maxy)\n    mask_grid = \"Generate a new grid with the same size as the target_grid. If the pixel in the subgrid is non-black, the value in the new grid is teal; otherwise, it is black\"(target_grid)\n    input_grid[minx:maxx + 1, miny:maxy + 1] = black\n    ans = \"Traverse all the elements in the inputgrid, match each pixel with a grid same as mask_grid, if the current pixel is matched, overwrite the position with a grid same as target_grid\"(input_grid, target_grid, mask_grid)\n    return ans", "prompt": "In the input, you should see a n*n grid with multiple color pixels.", "subfunctions": ["blacken_teal_pixels", "find_bounding_box", "extract_subgrid", "generate_teal_mask", "overwrite_pixels"], "parent": null}}, "entry": "main"}
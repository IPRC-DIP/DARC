{"funs": {"find_yellow_pixels": {"code": "def find_yellow_pixels(input_grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Given an input grid, this function finds the first and last yellow pixels and returns their coordinates as a tuple (\n    \"\"\"\n    rows = input_grid.shape[0]\n    cols = input_grid.shape[1]\n    x1, y1, x2, y2 = (rows, cols, -1, -1)\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] == yellow:\n                x1 = min(x1, i)\n                y1 = min(y1, j)\n                x2 = max(x2, i)\n                y2 = max(y2, j)\n    return (x1, y1, x2, y2)", "prompt": "Given an input grid, this function finds the first and last yellow pixels and returns their coordinates as a tuple (", "subfunctions": [], "parent": "main"}, "update_min_max_coordinates": {"code": "def update_min_max_coordinates(grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Given an input grid, this function returns the smallest x, the smallest y, the largest x, and the largest y coordina\n    \"\"\"\n    rows = grid.shape[0]\n    cols = grid.shape[1]\n    minx, miny, maxx, maxy = (rows, cols, -1, -1)\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] != black:\n                minx = min(minx, i)\n                miny = min(miny, j)\n                maxx = max(maxx, i)\n                maxy = max(maxy, j)\n    return (minx, miny, maxx, maxy)", "prompt": "Given an input grid, this function returns the smallest x, the smallest y, the largest x, and the largest y coordina", "subfunctions": [], "parent": "main"}, "count_non_black_pixels": {"code": "def count_non_black_pixels(ans_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Given an input grid, this function counts the number of unique non-black pixels and their total count and returns them as a tuple (kind, cnt).\n    \"\"\"\n    kind = len(np.unique(ans_grid)) - 1\n    cnt = np.count_nonzero(ans_grid != black)\n    return (kind, cnt)", "prompt": "Traverse all pixels in ansgrid, count the kind and quantity of non-black pixels, and return (kind, cnt)", "subfunctions": [], "parent": "main"}, "expand_target_grid": {"code": "def expand_target_grid(target_grid: np.ndarray, side_length: float) -> np.ndarray:\n    \"\"\"\n    Given a target grid and a side length, this function expands the target grid proportionally by the side length times and returns the expanded grid.\n    \"\"\"\n    return np.repeat(np.repeat(target_grid, side_length, axis=0), side_length, axis=1)", "prompt": "Expand the target_grid proportionally by the side_length times, and the shape becomes (4*target_grid.shape[0],4*target_grid.shape[1])", "subfunctions": [], "parent": "main"}, "copy_target_grid_to_first_non_black_non_yellow_pixel": {"code": "def copy_target_grid_to_first_non_black_non_yellow_pixel(ans_grid: np.ndarray, target_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given ans_grid and target_grid, this function finds the first non-black and non-yellow pixel (x, y) in ans_grid and copies target_grid to this position.\n    \"\"\"\n    rows = ans_grid.shape[0]\n    cols = ans_grid.shape[1]\n    for i in range(rows):\n        for j in range(cols):\n            if ans_grid[i][j] != black and ans_grid[i][j] != yellow:\n                ans_grid[i:i + target_grid.shape[0], j:j + target_grid.shape[1]] = target_grid\n                return ans_grid\n    return ans_grid", "prompt": "Find the first non-black and non-yellow pixel (x, y) in ans_grid, copy target_grid as grid to this position", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    x1, y1, x2, y2 = \"Given an input grid, this function finds the first and last yellow pixels and returns their coordinates as a tuple (\"(input_grid)\n    ans_grid = input_grid[x1:x2 + 1, y1:y2 + 1].copy()\n    input_grid[x1:x2 + 1, y1:y2 + 1] = black\n    minx, miny, maxx, maxy = \"Given an input grid, this function returns the smallest x, the smallest y, the largest x, and the largest y coordina\"(input_grid)\n    target_grid = input_grid[minx:maxx + 1, miny:maxy + 1]\n    kind, cnt = \"Traverse all pixels in ansgrid, count the kind and quantity of non-black pixels, and return (kind, cnt)\"(ans_grid)\n    import math\n    side_length = math.sqrt(cnt / (kind - 1))\n    target_grid = \"Expand the target_grid proportionally by the side_length times, and the shape becomes (4*target_grid.shape[0],4*target_grid.shape[1])\"(target_grid, side_length)\n    ans = \"Find the first non-black and non-yellow pixel (x, y) in ans_grid, copy target_grid as grid to this position\"(ans_grid, target_grid)\n    return ans", "prompt": "In the input, you should see a n*n grid with multiple color pixels.", "subfunctions": ["find_yellow_pixels", "update_min_max_coordinates", "count_non_black_pixels", "expand_target_grid", "copy_target_grid_to_first_non_black_non_yellow_pixel"], "parent": null}}, "entry": "main"}
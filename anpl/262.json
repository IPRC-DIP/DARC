{"funs": {"divide_into_sub_grids": {"code": "def divide_into_sub_grids(input_grid: np.ndarray) -> List[np.ndarray]:\n    sub_grids = []\n    for i in range(0, input_grid.shape[0], 3):\n        for j in range(0, input_grid.shape[1], 3):\n            sub_grid = input_grid[i:i + 3, j:j + 3]\n            sub_grids.append(sub_grid)\n    return sub_grids", "prompt": "divide the input into several 3*3 grid", "subfunctions": [], "parent": "main"}, "find_grid_with_most_non_black_pixels": {"code": "def find_grid_with_most_non_black_pixels(sub_grids: List[np.ndarray]) -> np.ndarray:\n    max_non_black_pixels = -1\n    max_non_black_pixels_grid = None\n    for sub_grid in sub_grids:\n        non_black_pixels = np.count_nonzero(sub_grid != black)\n        if non_black_pixels > max_non_black_pixels:\n            max_non_black_pixels = non_black_pixels\n            max_non_black_pixels_grid = sub_grid\n    return max_non_black_pixels_grid", "prompt": "each 3*3 grid has several non-black pixels, output the 3*3 grid that has the most non-black pixels", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    sub_grids = \"divide the input into several 3*3 grid\"(input_grid)\n    output_grid = \"each 3*3 grid has several non-black pixels, output the 3*3 grid that has the most non-black pixels\"(sub_grids)\n    return output_grid", "prompt": null, "subfunctions": ["divide_into_sub_grids", "find_grid_with_most_non_black_pixels"], "parent": null}}, "entry": "main"}
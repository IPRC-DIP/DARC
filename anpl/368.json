{"funs": {"count_connected_black_points": {"code": "def count_connected_black_points(input_grid: np.ndarray, i: int, j: int) -> int:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to count how many black points are connected to the given point.                                                   \n    It returns the count of connected black points.                                                                                                      \n    \"\"\"\n    if input_grid[i][j] != black:\n        return 0\n    count = 1\n    input_grid[i][j] = yellow\n    if i > 0:\n        count += count_connected_black_points(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        count += count_connected_black_points(input_grid, i + 1, j)\n    if j > 0:\n        count += count_connected_black_points(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        count += count_connected_black_points(input_grid, i, j + 1)\n    return count", "prompt": "This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \nIt performs a floodfill algorithm to count how many black points are connected to the given point.                                                   \nIt returns the count of connected black points.                                                                                                      ", "subfunctions": [], "parent": "main"}, "fill_single_black_area": {"code": "def fill_single_black_area(input_grid: np.ndarray, i: int, j: int) -> None:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to color the black area of the given point blue.                                                                   \n    \"\"\"\n    if input_grid[i][j] != yellow:\n        return\n    input_grid[i][j] = green\n    if i > 0:\n        fill_single_black_area(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        fill_single_black_area(input_grid, i + 1, j)\n    if j > 0:\n        fill_single_black_area(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        fill_single_black_area(input_grid, i, j + 1)", "prompt": "This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \nIt performs a floodfill algorithm to color the black area of the given point blue.                                                                   ", "subfunctions": [], "parent": "main"}, "fill_single_black_area_red": {"code": "def fill_single_black_area_red(input_grid: np.ndarray, i: int, j: int) -> None:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to color the black area of the given point blue.                                                                   \n    \"\"\"\n    if input_grid[i][j] != yellow:\n        return\n    input_grid[i][j] = red\n    if i > 0:\n        fill_single_black_area_red(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        fill_single_black_area_red(input_grid, i + 1, j)\n    if j > 0:\n        fill_single_black_area_red(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        fill_single_black_area_red(input_grid, i, j + 1)", "prompt": "This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \nIt performs a floodfill algorithm to color the black area of the given point blue.                                                                   ", "subfunctions": [], "parent": "main"}, "fill_single_black_area_blue": {"code": "def fill_single_black_area_blue(input_grid: np.ndarray, i: int, j: int) -> None:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to color the black area of the given point blue.                                                                   \n    \"\"\"\n    if input_grid[i][j] != yellow:\n        return\n    input_grid[i][j] = blue\n    if i > 0:\n        fill_single_black_area_blue(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        fill_single_black_area_blue(input_grid, i + 1, j)\n    if j > 0:\n        fill_single_black_area_blue(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        fill_single_black_area_blue(input_grid, i, j + 1)", "prompt": "This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \nIt performs a floodfill algorithm to color the black area of the given point blue.                                                                   ", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    for i in range(len(input_grid)):\n        for j in range(len(input_grid[0])):\n            count = \"This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \nIt performs a floodfill algorithm to count how many black points are connected to the given point.                                                   \nIt returns the count of connected black points.                                                                                                      \"(input_grid, i, j)\n            if count == 1:\n                \"This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \nIt performs a floodfill algorithm to color the black area of the given point blue.                                                                   \"(input_grid, i, j)\n            elif count == 2:\n                \"This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \nIt performs a floodfill algorithm to color the black area of the given point blue.                                                                   \"(input_grid, i, j)\n            elif count == 3:\n                \"This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \nIt performs a floodfill algorithm to color the black area of the given point blue.                                                                   \"(input_grid, i, j)\n    return input_grid", "prompt": null, "subfunctions": ["count_connected_black_points", "fill_single_black_area", "fill_single_black_area_red", "fill_single_black_area_blue"], "parent": null}}, "entry": "main"}
{"funs": {"extend_green_pixel": {"code": "def extend_green_pixel(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Extend the green pixel to the right until it meets a non-black pixel\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    A numpy array representing the output grid with the green pixel extended to the right\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    for i in range(output_grid.shape[0]):\n        for j in range(output_grid.shape[1]):\n            if output_grid[i][j] == green:\n                k = j + 1\n                while k < output_grid.shape[1] and output_grid[i][k] == black:\n                    k += 1\n                output_grid[i][j:k] = green\n    return output_grid", "prompt": "Extend the green pixel to the right until it meets a non-black pixel", "subfunctions": [], "parent": "main"}, "extend_rightmost_green_pixel_up": {"code": "def extend_rightmost_green_pixel_up(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Extend only the rightmost green pixel to the up until it meets a non-black pixel\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    A numpy array representing the output grid with the rightmost green pixel extended to the up\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    for i in range(output_grid.shape[0]):\n        for j in range(output_grid.shape[1] - 1, -1, -1):\n            if output_grid[i][j] == green:\n                k = i - 1\n                while k >= 0 and output_grid[k][j] == black:\n                    k -= 1\n                output_grid[k + 1:i + 1, j] = green\n                break\n    return output_grid", "prompt": "Extend only the rightmost green pixel to the up until it meets a non-black pixel", "subfunctions": [], "parent": "main"}, "extend_upmost_green_pixel_left": {"code": "def extend_upmost_green_pixel_left(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Extend only the up most green pixel to the left until it meets a non-black pixel\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    A numpy array representing the output grid with the up most green pixel extended to the left\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    for j in range(output_grid.shape[1]):\n        for i in range(output_grid.shape[0]):\n            if output_grid[i][j] == green:\n                k = j - 1\n                while k >= 0 and output_grid[i][k] == black:\n                    k -= 1\n                output_grid[i][k + 1:j + 1] = green\n                break\n    return output_grid", "prompt": "Extend only the up most green pixel to the left until it meets a non-black pixel", "subfunctions": [], "parent": "main"}, "main": {"code": "def main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = \"Extend the green pixel to the right until it meets a non-black pixel\"(input_grid)\n    output_grid = \"Extend only the rightmost green pixel to the up until it meets a non-black pixel\"(output_grid)\n    output_grid = \"Extend only the up most green pixel to the left until it meets a non-black pixel\"(output_grid)\n    return output_grid", "prompt": null, "subfunctions": ["extend_green_pixel", "extend_rightmost_green_pixel_up", "extend_upmost_green_pixel_left"], "parent": null}}, "entry": "main"}
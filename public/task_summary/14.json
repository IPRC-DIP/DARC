{"id": 14, "train_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 4, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 4, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 7, 1, 7, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 4, 0], [0, 0, 7, 0, 0, 0, 2, 0, 0], [0, 7, 1, 7, 0, 4, 0, 4, 0], [0, 0, 7, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0], [4, 0, 4, 0, 0, 7, 1, 7, 0], [0, 2, 0, 0, 0, 0, 7, 0, 0], [4, 0, 4, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 4, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 4, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 7, 1, 7, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 4, 0, 4, 0, 7, 1, 7, 0], [0, 0, 2, 0, 0, 0, 7, 0, 0], [0, 4, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 4], [0, 6, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 4, 0, 4]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = \"same as input grid\"(input_grid)\n    red_positions = \"find all positions of red elements\"(input_grid)\n    blue_positions = \"find all positions of blue elements\"(input_grid)\n    output_grid = \"set the elements in up-left, up-right, down-left and down-right of input position to yellow in input grid. there will be one or more positions in input position\"(output_grid, red_positions)\n    output_grid = \"set the elements in up, down, left and right of input position to yellow in input grid. there will be one or more positions in input position\"(output_grid, blue_positions)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef set_orange_around_position(input_grid: np.ndarray, positions: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    Sets the elements in up, down, left and right of input positions to orange in input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    positions: A list of tuples representing the positions in the input grid.\n    \n    Returns:\n    A numpy array representing the input grid with orange elements around the input positions.\n    \"\"\"\n    for i, j in positions:\n        if i > 0:\n            input_grid[i - 1][j] = orange\n        if i < input_grid.shape[0] - 1:\n            input_grid[i + 1][j] = orange\n        if j > 0:\n            input_grid[i][j - 1] = orange\n        if j < input_grid.shape[1] - 1:\n            input_grid[i][j + 1] = orange\n    return input_grid\n\ndef set_yellow_around_position(input_grid: np.ndarray, positions: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    Sets the elements in up-left, up-right, down-left and down-right of input positions to yellow in input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    positions: A list of tuples representing the positions in the input grid.\n    \n    Returns:\n    A numpy array representing the input grid with yellow elements around the input positions.\n    \"\"\"\n    for i, j in positions:\n        if i > 0 and j > 0:\n            input_grid[i - 1][j - 1] = yellow\n        if i > 0 and j < input_grid.shape[1] - 1:\n            input_grid[i - 1][j + 1] = yellow\n        if i < input_grid.shape[0] - 1 and j > 0:\n            input_grid[i + 1][j - 1] = yellow\n        if i < input_grid.shape[0] - 1 and j < input_grid.shape[1] - 1:\n            input_grid[i + 1][j + 1] = yellow\n    return input_grid\n\ndef find_blue_positions(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Returns a list of tuples representing the positions of all blue elements in the input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of tuples representing the positions of all blue elements in the input grid.\n    \"\"\"\n    blue_positions = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == blue:\n                blue_positions.append((i, j))\n    return blue_positions\n\ndef find_red_positions(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Returns a list of tuples representing the positions of all red elements in the input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of tuples representing the positions of all red elements in the input grid.\n    \"\"\"\n    red_positions = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                red_positions.append((i, j))\n    return red_positions\n\ndef identity(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns the input grid as is.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array representing the input grid.\n    \"\"\"\n    return input_grid\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = identity(input_grid)\n    red_positions = find_red_positions(input_grid)\n    blue_positions = find_blue_positions(input_grid)\n    output_grid = set_yellow_around_position(output_grid, red_positions)\n    output_grid = set_orange_around_position(output_grid, blue_positions)\n    return output_grid"}
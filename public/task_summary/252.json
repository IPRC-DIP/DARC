{"id": 252, "train_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[8, 8, 2, 2], [8, 0, 0, 2], [3, 0, 0, 1], [3, 3, 1, 1]], [[1, 1, 8, 8], [1, 0, 0, 8], [4, 0, 0, 2], [4, 4, 2, 2]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[3, 3, 8, 8], [3, 0, 0, 8], [1, 0, 0, 6], [1, 1, 6, 6]]]}, "solved": true, "generalizable": true, "anpl": "def find_non_black_square_on_lower_left(input_grid: np.ndarray) -> int:\n    for i in range(input_grid.shape[0] - 1):\n        for j in range(input_grid.shape[1] - 1):\n            if input_grid[i][j] == black and input_grid[i + 1][j] != black and (input_grid[i][j - 1] != black):\n                return input_grid[i][j - 1]\n    return -1\n\ndef find_non_black_square_on_upper_right(input_grid: np.ndarray) -> int:\n    for i in range(1, input_grid.shape[0]):\n        for j in range(1, input_grid.shape[1]):\n            if input_grid[i][j] == black and input_grid[i - 1][j] != black and (input_grid[i][j + 1] != black):\n                return input_grid[i][j + 1]\n    return -1\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    color1 = \" Find a black square with a non-black square on its upper and left sides, and record the color of the non-black square \"(input_grid)\n    color2 = find_non_black_square_on_upper_right(input_grid)\n    color3 = find_non_black_square_on_lower_left(input_grid)\n    color4 = \" Find a black square with a non-black square on its lower and right sides, and record the color of the non-black square \"(input_grid)\n    output_grid = np.zeros((4, 4), dtype=int)\n    output_grid = \" Change the input points to the input color\"(output_grid, color1, [(0, 0), (0, 1), (1, 0)])\n    output_grid = \" Change the input points to the input color\"(output_grid, color2, [(0, 2), (0, 3), (1, 3)])\n    output_grid = \" Change the input points to the input color\"(output_grid, color3, [(2, 0), (3, 0), (3, 1)])\n    output_grid = \" Change the input points to the input color\"(output_grid, color4, [(2, 3), (3, 2), (3, 3)])\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_input_points_to_input_color(output_grid: np.ndarray, color: int, points: List[Tuple[int, int]]) -> np.ndarray:\n    for point in points:\n        output_grid[point[0]][point[1]] = color\n    return output_grid\n\ndef find_color_of_non_black_square_on_lower_right(input_grid: np.ndarray) -> int:\n    for i in range(input_grid.shape[0] - 1):\n        for j in range(input_grid.shape[1] - 1):\n            if input_grid[i][j] == black and input_grid[i + 1][j] != black and (input_grid[i][j + 1] != black):\n                return input_grid[i + 1][j + 1]\n    return -1\n\ndef find_non_black_square_on_lower_left(input_grid: np.ndarray) -> int:\n    for i in range(input_grid.shape[0] - 1):\n        for j in range(input_grid.shape[1] - 1):\n            if input_grid[i][j] == black and input_grid[i + 1][j] != black and (input_grid[i][j - 1] != black):\n                return input_grid[i][j - 1]\n    return -1\n\ndef find_non_black_square_on_upper_right(input_grid: np.ndarray) -> int:\n    for i in range(1, input_grid.shape[0]):\n        for j in range(1, input_grid.shape[1]):\n            if input_grid[i][j] == black and input_grid[i - 1][j] != black and (input_grid[i][j + 1] != black):\n                return input_grid[i][j + 1]\n    return -1\n\ndef find_color(input_grid: np.ndarray) -> int:\n    for i in range(1, input_grid.shape[0]):\n        for j in range(1, input_grid.shape[1]):\n            if input_grid[i][j] == black and input_grid[i - 1][j] != black and (input_grid[i][j - 1] != black):\n                return input_grid[i][j - 1]\n    return -1\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    color1 = find_color(input_grid)\n    color2 = find_non_black_square_on_upper_right(input_grid)\n    color3 = find_non_black_square_on_lower_left(input_grid)\n    color4 = find_color_of_non_black_square_on_lower_right(input_grid)\n    output_grid = np.zeros((4, 4), dtype=int)\n    output_grid = change_input_points_to_input_color(output_grid, color1, [(0, 0), (0, 1), (1, 0)])\n    output_grid = change_input_points_to_input_color(output_grid, color2, [(0, 2), (0, 3), (1, 3)])\n    output_grid = change_input_points_to_input_color(output_grid, color3, [(2, 0), (3, 0), (3, 1)])\n    output_grid = change_input_points_to_input_color(output_grid, color4, [(2, 3), (3, 2), (3, 3)])\n    return output_grid"}
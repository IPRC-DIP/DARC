{"id": 237, "train_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 4, 4, 4, 4, 0], [2, 8, 0, 0, 8, 1], [2, 0, 8, 0, 1, 1], [2, 2, 8, 8, 1, 1], [2, 0, 3, 0, 8, 1], [0, 3, 3, 3, 3, 0]], [[0, 3, 3, 3, 0], [6, 0, 3, 0, 4], [6, 6, 8, 4, 4], [6, 0, 2, 8, 4], [0, 2, 2, 2, 0]], [[0, 7, 7, 7, 7, 0], [4, 8, 7, 0, 8, 6], [4, 0, 8, 8, 0, 6], [4, 0, 8, 0, 6, 6], [4, 8, 1, 0, 8, 6], [0, 1, 1, 1, 1, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 1, 1, 1, 1, 1, 0], [2, 8, 1, 0, 1, 8, 4], [2, 2, 0, 1, 8, 0, 4], [2, 0, 2, 8, 4, 4, 4], [2, 0, 0, 3, 0, 0, 4], [2, 8, 3, 0, 3, 8, 4], [0, 3, 3, 3, 3, 3, 0]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    p = \"find all not black and not teal pixels\"(input_grid)\n    t = \"find all teal pixels\"(input_grid)\n    s = \"get the max and min row and col of pixels in t, return the pixels between and in this four edge\"(input_grid, t)\n    l = \"get the max and min row and col of pixels in p, return the pixels between and in this four edge\"(input_grid, p)\n    o = \"create a copy of l, find the inner black area in l, copy the square area s to the black area in the copy of l\"(s, l)\n    out = \"if any teal pixel in o, if it is not in the diagonal of o, turn the color of the teal pixel, if row > col and rol + col < height - 1 to the color of left edge line, if row > col and rol + col > height - 1 to the color of bottom edge line, if row < col and rol + col < height - 1 to the color of top edge line, if row < col and rol + col > height - 1 to the color of right edge line\"(o)\n    return out", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_teal_pixels(o: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function replaces teal pixels in o based on their position relative to the diagonal of o.\n\n    Args:\n    - o: a numpy array representing the copy of l with the square area s copied to the black area in the middle\n\n    Returns:\n    - out: a numpy array representing the copy of l with the square area s copied to the black area in the middle and teal pixels replaced based on their position relative to the diagonal of o\n    \"\"\"\n    height, width = o.shape\n    diagonal = np.diag(np.full(height, True))\n    rows, cols = np.where((o == teal) & (diagonal == False))\n    for row, col in zip(rows, cols):\n        if row > col and row + col < height - 1:\n            o[row, col] = o[:, 0][row]\n        elif row > col and row + col > height - 1:\n            o[row, col] = o[-1, :][col]\n        elif row < col and row + col < height - 1:\n            o[row, col] = o[0, :][col]\n        elif row < col and row + col > height - 1:\n            o[row, col] = o[:, -1][row]\n    return o\n\ndef copy_square_to_middle(s: np.ndarray, l: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function creates a copy of l, finds the inner black area in l, and copies the square area s to the black area in the copy of l.\n\n    Args:\n    - s: a numpy array representing the smallest rectangle that covers all teal pixels in the input grid\n    - l: a numpy array representing the smallest rectangle that covers all non-black teal pixels in the input grid\n\n    Returns:\n    - out: a numpy array representing the copy of l with the square area s copied to the black area in the middle\n    \"\"\"\n    out = np.copy(l)\n    rows, cols = np.where(l == black)\n    min_row, max_row = (np.min(rows), np.max(rows))\n    min_col, max_col = (np.min(cols), np.max(cols))\n    height, width = l.shape\n    s_height, s_width = s.shape\n    row_offset = (height - s_height) // 2\n    col_offset = (width - s_width) // 2\n    out[min_row + row_offset:min_row + row_offset + s_height, min_col + col_offset:min_col + col_offset + s_width] = s\n    return out\n\ndef find_smallest_covering_area(input_grid: np.ndarray, p: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function finds the smallest rectangle that covers all non-black teal pixels in the input grid.\n\n    Args:\n    - input_grid: a numpy array representing the input grid\n    - p: a numpy array representing the non-black teal pixels in the input grid\n\n    Returns:\n    - l: a numpy array representing the smallest rectangle that covers all non-black teal pixels in the input grid\n    \"\"\"\n    rows, cols = np.where(p == 1)\n    min_row, max_row = (np.min(rows), np.max(rows))\n    min_col, max_col = (np.min(cols), np.max(cols))\n    l = input_grid[min_row:max_row + 1, min_col:max_col + 1]\n    return l\n\ndef find_smallest_area(input_grid: np.ndarray, t: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function finds the smallest rectangle that covers all teal pixels in the input grid.\n\n    Args:\n    - input_grid: a numpy array representing the input grid\n    - t: a numpy array representing the teal pixels in the input grid\n\n    Returns:\n    - s: a numpy array representing the smallest rectangle that covers all teal pixels in the input grid\n    \"\"\"\n    rows, cols = np.where(t == 1)\n    min_row, max_row = (np.min(rows), np.max(rows))\n    min_col, max_col = (np.min(cols), np.max(cols))\n    s = input_grid[min_row:max_row + 1, min_col:max_col + 1]\n    return s\n\ndef find_teal_pixels(input_grid: np.ndarray) -> np.ndarray:\n    teal_pixels = np.where(input_grid == teal, 1, 0)\n    return teal_pixels\n\ndef find_non_black_teal_pixels(input_grid: np.ndarray) -> np.ndarray:\n    non_black_teal_pixels = np.where((input_grid != black) & (input_grid != teal), 1, 0)\n    return non_black_teal_pixels\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    p = find_non_black_teal_pixels(input_grid)\n    t = find_teal_pixels(input_grid)\n    s = find_smallest_area(input_grid, t)\n    l = find_smallest_covering_area(input_grid, p)\n    o = copy_square_to_middle(s, l)\n    out = replace_teal_pixels(o)\n    return out"}
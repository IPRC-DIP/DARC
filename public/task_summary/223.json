{"id": 223, "train_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 1, 0, 1, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], [0, 5, 1, 0, 0, 1, 0, 1, 0, 0, 1, 5, 0], [0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 5, 3, 0, 3, 3, 3, 0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 3, 0, 3, 0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 3, 3, 3, 0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 4, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0], [0, 0, 4, 0, 4, 0, 0, 4, 0, 0, 0, 4, 5, 0], [0, 0, 4, 0, 4, 0, 0, 4, 0, 0, 0, 4, 0, 0], [0, 5, 4, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 8, 8, 8, 8, 0, 0, 8, 0, 0, 0], [0, 0, 5, 8, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 8, 8, 8, 8, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 5, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    color3 = \" find the third color( color3 )besides black and gray \"(input_grid)\n    (xmin, xmax, ymin, ymax) = \" Find the xmin, xmax, ymin, ymax of the four gray coordinates \"(input_grid)\n    p1 = (xmin + 1, ymin + 1)\n    p2 = (xmin + 1, ymax - 1)\n    p3 = (xmax - 1, ymin + 1)\n    p4 = (xmax - 1, ymax - 1)\n    output_grid = np.copy(input_grid)\n    output_grid = \" Connect p1 and p2 with a line of color3. \"(output_grid, color3, p1, p2)\n    output_grid = \" Connect p3 and p4 with a line of color3 \"(output_grid, color3, p3, p4)\n    output_grid = \" Connect p1 and p3 with a line of color3\"(output_grid, color3, p1, p3)\n    output_grid = \" Connect p2 and p4 with a line of color3 \"(output_grid, color3, p2, p4)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef connect_p2_p4_with_color3(input_grid: np.ndarray, color3: int, p2: Tuple[int, int], p4: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Given an input grid, color3, p2 and p4, this function connects p2 and p4 with a line of color3.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    color3: An integer representing the third color present in the grid.\n    p2: A tuple of two integers representing the coordinates of point p2.\n    p4: A tuple of two integers representing the coordinates of point p4.\n\n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    x2, y2 = p2\n    x4, y4 = p4\n    if x2 == x4:\n        for y in range(min(y2, y4), max(y2, y4) + 1):\n            input_grid[x2][y] = color3\n    elif y2 == y4:\n        for x in range(min(x2, x4), max(x2, x4) + 1):\n            input_grid[x][y2] = color3\n    return input_grid\n\ndef connect_p1_p3_with_color3(input_grid: np.ndarray, color3: int, p1: Tuple[int, int], p3: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Given an input grid, color3, p1 and p3, this function connects p1 and p3 with a line of color3.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    color3: An integer representing the third color present in the grid.\n    p1: A tuple of two integers representing the coordinates of point p1.\n    p3: A tuple of two integers representing the coordinates of point p3.\n\n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    x1, y1 = p1\n    x3, y3 = p3\n    if x1 == x3:\n        for y in range(min(y1, y3), max(y1, y3) + 1):\n            input_grid[x1][y] = color3\n    elif y1 == y3:\n        for x in range(min(x1, x3), max(x1, x3) + 1):\n            input_grid[x][y1] = color3\n    return input_grid\n\ndef connect_p3_p4_with_color3(input_grid: np.ndarray, color3: int, p3: Tuple[int, int], p4: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Given an input grid, color3, p3 and p4, this function connects p3 and p4 with a line of color3.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    color3: An integer representing the third color present in the grid.\n    p3: A tuple of two integers representing the coordinates of point p3.\n    p4: A tuple of two integers representing the coordinates of point p4.\n\n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    x3, y3 = p3\n    x4, y4 = p4\n    if x3 == x4:\n        for y in range(min(y3, y4), max(y3, y4) + 1):\n            input_grid[x3][y] = color3\n    elif y3 == y4:\n        for x in range(min(x3, x4), max(x3, x4) + 1):\n            input_grid[x][y3] = color3\n    return input_grid\n\ndef connect_p1_p2_with_color3(input_grid: np.ndarray, color3: int, p1: Tuple[int, int], p2: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Given an input grid, color3, p1 and p2, this function connects p1 and p2 with a line of color3.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    color3: An integer representing the third color present in the grid.\n    p1: A tuple of two integers representing the coordinates of point p1.\n    p2: A tuple of two integers representing the coordinates of point p2.\n\n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            input_grid[x1][y] = color3\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            input_grid[x][y1] = color3\n    return input_grid\n\ndef find_gray_coordinates(input_grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Given an input grid, this function returns the minimum and maximum x and y coordinates of the gray cells.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A tuple of four integers representing the minimum and maximum x and y coordinates of the gray cells.\n    \"\"\"\n    gray_indices = np.where(input_grid == grey)\n    xmin = np.min(gray_indices[0])\n    xmax = np.max(gray_indices[0])\n    ymin = np.min(gray_indices[1])\n    ymax = np.max(gray_indices[1])\n    return (xmin, xmax, ymin, ymax)\n\ndef find_third_color(input_grid: np.ndarray) -> int:\n    \"\"\"\n    Given an input grid, this function returns the third color (besides black and gray) present in the grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    An integer representing the third color present in the grid.\n    \"\"\"\n    colors, counts = np.unique(input_grid, return_counts=True)\n    for color, count in zip(colors, counts):\n        if color not in [black, grey] and count > 0:\n            return color\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    color3 = find_third_color(input_grid)\n    xmin, xmax, ymin, ymax = find_gray_coordinates(input_grid)\n    p1 = (xmin + 1, ymin + 1)\n    p2 = (xmin + 1, ymax - 1)\n    p3 = (xmax - 1, ymin + 1)\n    p4 = (xmax - 1, ymax - 1)\n    output_grid = np.copy(input_grid)\n    output_grid = connect_p1_p2_with_color3(output_grid, color3, p1, p2)\n    output_grid = connect_p3_p4_with_color3(output_grid, color3, p3, p4)\n    output_grid = connect_p1_p3_with_color3(output_grid, color3, p1, p3)\n    output_grid = connect_p2_p4_with_color3(output_grid, color3, p2, p4)\n    return output_grid"}
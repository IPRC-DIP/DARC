{"id": 251, "train_io": {"inputs": [[[2, 0, 0], [0, 2, 0], [0, 0, 2]], [[0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 0], [9, 0, 0, 0, 0, 0, 9, 0], [0, 9, 0, 0, 0, 0, 0, 9], [0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 9, 0, 0, 0, 0]], [[0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0], [3, 0, 0, 0, 0, 3], [0, 3, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0]]], "outputs": [[[2, 0, 0], [0, 4, 0], [0, 0, 2]], [[0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 9, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0], [9, 0, 0, 0, 0, 0, 9, 0], [0, 4, 0, 0, 0, 0, 0, 4], [0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0]], [[0, 0, 3, 0, 0, 0], [0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 3, 0], [3, 0, 0, 0, 0, 4], [0, 4, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 6], [6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 6, 0]]], "outputs": [[[0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 4], [6, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0]]]}, "solved": true, "generalizable": true, "anpl": "def change_pixels_in_bottom_right_direction(grid: np.ndarray, loc: Tuple[int, int], color: int) -> np.ndarray:\n    (i, j) = loc\n    colour = color\n    while i < grid.shape[0] and j < grid.shape[1]:\n        if grid[i][j] != black:\n            grid[i][j] = colour\n        colour = yellow if colour != yellow else color\n        i += 1\n        j += 1\n    return grid\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = input_grid\n    locs = \"get the location of all the pixels which are not black in the first row or in the first coloum\"(input_grid)\n    color = \"get the color of pixel\"(input_grid, locs[0])\n    for loc in locs:\n        output_grid = change_pixels_in_bottom_right_direction(output_grid, loc, color)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_pixels_in_bottom_right_direction(grid: np.ndarray, loc: Tuple[int, int], color: int) -> np.ndarray:\n    i, j = loc\n    colour = color\n    while i < grid.shape[0] and j < grid.shape[1]:\n        if grid[i][j] != black:\n            grid[i][j] = colour\n        colour = yellow if colour != yellow else color\n        i += 1\n        j += 1\n    return grid\n\ndef get_pixel_color(grid: np.ndarray, loc: Tuple[int, int]) -> int:\n    return grid[loc[0]][loc[1]]\n\ndef get_non_black_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    non_black_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black and (i == 0 or j == 0):\n                non_black_pixels.append((i, j))\n    return non_black_pixels\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = input_grid\n    locs = get_non_black_pixels(input_grid)\n    color = get_pixel_color(input_grid, locs[0])\n    for loc in locs:\n        output_grid = change_pixels_in_bottom_right_direction(output_grid, loc, color)\n    return output_grid"}
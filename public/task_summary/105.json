{"id": 105, "train_io": {"inputs": [[[8, 6], [6, 8]], [[7, 7, 8], [7, 7, 8], [8, 8, 8]], [[6, 9, 9], [6, 4, 4], [6, 4, 4]]], "outputs": [[[8, 6, 6, 8], [6, 8, 8, 6], [6, 8, 8, 6], [8, 6, 6, 8]], [[7, 7, 8, 8, 7, 7], [7, 7, 8, 8, 7, 7], [8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8], [7, 7, 8, 8, 7, 7], [7, 7, 8, 8, 7, 7]], [[6, 9, 9, 6, 6, 6], [6, 4, 4, 4, 4, 9], [6, 4, 4, 4, 4, 9], [9, 4, 4, 4, 4, 6], [9, 4, 4, 4, 4, 6], [6, 6, 6, 9, 9, 6]]]}, "test_io": {"inputs": [[[1, 4, 1], [4, 9, 4], [9, 1, 9]]], "outputs": [[[1, 4, 1, 9, 4, 1], [4, 9, 4, 1, 9, 4], [9, 1, 9, 9, 4, 1], [1, 4, 9, 9, 1, 9], [4, 9, 1, 4, 9, 4], [1, 4, 9, 1, 4, 1]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = \"return the empty grid which is the double size of input_grid\"(input_grid)\n    output_grid = \"put the input_grid at the top-left of output_grid\"(input_grid, output_grid)\n    input_grid = \"rotate the input_grid 90 degrees clockwise\"(input_grid)\n    output_grid = \"put the input_grid at the top-right of output_grid\"(input_grid, output_grid)\n    input_grid = \"rotate the input_grid 90 degrees clockwise\"(input_grid)\n    output_grid = \"put the input_grid at the bottom-right of output_grid\"(input_grid, output_grid)\n    input_grid = \"rotate the input_grid 90 degrees clockwise\"(input_grid)\n    output_grid = \"put the input_grid at the bottom-left of output_grid\"(input_grid, output_grid)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef put_input_grid_at_bottom_left(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[-input_grid.shape[0]:, :input_grid.shape[1]] = input_grid\n    return output_grid\n\ndef put_input_grid_at_bottom_right(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[-input_grid.shape[0]:, -input_grid.shape[1]:] = input_grid\n    return output_grid\n\ndef put_input_grid_at_top_right(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[:input_grid.shape[0], -input_grid.shape[1]:] = input_grid\n    return output_grid\n\ndef rotate_90_degrees_clockwise(input_grid: np.ndarray) -> np.ndarray:\n    return np.rot90(input_grid, k=-1)\n\ndef put_input_grid_at_top_left(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[:input_grid.shape[0], :input_grid.shape[1]] = input_grid\n    return output_grid\n\ndef get_empty_grid(input_grid: np.ndarray) -> np.ndarray:\n    return np.zeros((input_grid.shape[0] * 2, input_grid.shape[1] * 2))\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = get_empty_grid(input_grid)\n    output_grid = put_input_grid_at_top_left(input_grid, output_grid)\n    input_grid = rotate_90_degrees_clockwise(input_grid)\n    output_grid = put_input_grid_at_top_right(input_grid, output_grid)\n    input_grid = rotate_90_degrees_clockwise(input_grid)\n    output_grid = put_input_grid_at_bottom_right(input_grid, output_grid)\n    input_grid = rotate_90_degrees_clockwise(input_grid)\n    output_grid = put_input_grid_at_bottom_left(input_grid, output_grid)\n    return output_grid"}
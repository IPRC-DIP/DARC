{"id": 90, "train_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 8, 0, 0, 8], [0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 5, 0, 8, 0, 5, 0, 8, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0]], [[0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0], [8, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 5, 0, 0, 8, 8, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 8, 0, 8, 0, 0, 0, 8, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 8, 8, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0, 8, 0, 0, 0], [0, 0, 8, 5, 0, 8, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 5, 8, 0, 0, 0, 0], [0, 0, 8, 5, 0, 8, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 8, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]]], "outputs": [[[8, 0, 0, 0, 8], [5, 0, 0, 0, 5], [5, 0, 8, 0, 5], [5, 0, 0, 0, 5], [8, 0, 0, 0, 8]], [[8, 0, 0, 0, 0, 0, 8], [5, 0, 0, 0, 0, 0, 5], [5, 0, 0, 8, 8, 0, 5], [5, 0, 0, 0, 0, 0, 5], [8, 0, 8, 0, 0, 0, 8]], [[8, 0, 0, 0, 8], [5, 0, 0, 0, 5], [5, 0, 8, 0, 5], [5, 0, 0, 0, 5], [5, 0, 8, 0, 5], [8, 0, 0, 0, 8]]]}, "test_io": {"inputs": [[[8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 8, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 8], [5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 0, 0, 5, 0, 0, 8, 0, 0, 8, 0, 0, 0], [5, 0, 8, 5, 8, 0, 0, 0, 0, 0, 0, 0, 8], [5, 0, 0, 5, 0, 8, 0, 0, 0, 0, 0, 0, 0], [5, 8, 0, 5, 0, 0, 0, 0, 0, 0, 8, 0, 8], [5, 0, 0, 5, 0, 0, 0, 8, 0, 0, 0, 0, 0], [8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8]]], "outputs": [[[8, 0, 0, 8], [5, 8, 0, 5], [5, 0, 0, 5], [5, 0, 0, 5], [5, 0, 0, 5], [5, 0, 8, 5], [5, 0, 0, 5], [5, 8, 0, 5], [5, 0, 0, 5], [8, 0, 0, 8]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    grey_positions = \"find the positions of grey elements in input grid\"(input_grid)\n    (max_row, min_row, max_col, min_col) = \"return the max row, min row, max column, min column of input positions\"(grey_positions)\n    output_block = \"find the block in input grid according to the input max row, min row, max column and min column\"(input_grid, max_row + 1, min_row - 1, max_col, min_col)\n    return output_block", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_block(input_grid: np.ndarray, max_row: int, min_row: int, max_col: int, min_col: int) -> np.ndarray:\n    \"\"\"\n    Given an input grid and the maximum row, minimum row, maximum column, and minimum column of a block, \n    returns the block as a numpy ndarray.\n    \n    Args:\n    - input_grid: a numpy ndarray representing the input grid\n    - max_row: an integer representing the maximum row of the block\n    - min_row: an integer representing the minimum row of the block\n    - max_col: an integer representing the maximum column of the block\n    - min_col: an integer representing the minimum column of the block\n    \n    Returns:\n    - a numpy ndarray representing the block\n    \"\"\"\n    return input_grid[min_row:max_row + 1, min_col:max_col + 1]\n\ndef get_positions_bounds(positions: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Given a list of positions, returns the maximum row, minimum row, maximum column, and minimum column of the positions.\n    \n    Args:\n    - positions: a list of tuples representing positions\n    \n    Returns:\n    - a tuple of four integers representing the maximum row, minimum row, maximum column, and minimum column of the positions\n    \"\"\"\n    max_row = max(positions, key=lambda x: x[0])[0]\n    min_row = min(positions, key=lambda x: x[0])[0]\n    max_col = max(positions, key=lambda x: x[1])[1]\n    min_col = min(positions, key=lambda x: x[1])[1]\n    return (max_row, min_row, max_col, min_col)\n\ndef find_grey_positions(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an input grid, returns a list of tuples representing the positions of grey elements in the grid.\n    \n    Args:\n    - input_grid: a numpy ndarray representing the input grid\n    \n    Returns:\n    - a list of tuples representing the positions of grey elements in the grid\n    \"\"\"\n    grey_positions = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == grey:\n                grey_positions.append((i, j))\n    return grey_positions\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    grey_positions = find_grey_positions(input_grid)\n    max_row, min_row, max_col, min_col = get_positions_bounds(grey_positions)\n    output_block = find_block(input_grid, max_row + 1, min_row - 1, max_col, min_col)\n    return output_block"}
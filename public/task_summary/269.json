{"id": 269, "train_io": {"inputs": [[[0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 1, 0, 0, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0]], [[0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 0, 0, 1, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 7, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "solved": true, "generalizable": false, "anpl": "def move_green_pixels_next_to_red_pixel(output_grid: np.ndarray, red_pixel: Tuple[int, int], green_pixels: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"                                                                                                                                                                   \n    Given an output grid, the coordinates of the red pixel and a list of coordinates of the green pixels,                                                                 \n    moves the green pixels next to the red pixel in the output grid.                                                                                                      \n                                                                                                                                                                          \n    Args:                                                                                                                                                                 \n    output_grid: A numpy array representing the output grid.                                                                                                              \n    red_pixel: A tuple containing the x and y coordinates of the red pixel in the output grid.                                                                            \n    green_pixels: A list of tuples containing the x and y coordinates of the green pixels in the output grid.                                                             \n                                                                                                                                                                          \n    Returns:                                                                                                                                                              \n    A numpy array representing the output grid with the green pixels moved next to the red pixel.                                                                         \n    \"\"\"\n    for i in range(len(green_pixels)):\n        if red_pixel[0] == green_pixels[i][0] and red_pixel[1] < green_pixels[i][1]:\n            output_grid[red_pixel[0]][red_pixel[1] + 1] = green\n        elif red_pixel[0] == green_pixels[i][0] and red_pixel[1] > green_pixels[i][1]:\n            output_grid[red_pixel[0]][red_pixel[1] - 1] = green\n        elif red_pixel[1] == green_pixels[i][1] and red_pixel[0] > green_pixels[i][0]:\n            output_grid[red_pixel[0] + 1][red_pixel[1]] = green\n        elif red_pixel[1] == green_pixels[i][1] and red_pixel[0] < green_pixels[i][0]:\n            output_grid[red_pixel[0] - 1][red_pixel[1]] = green\n        output_grid[green_pixels[i][0]][green_pixels[i][1]] = black\n    return output_grid\n\ndef move_orange_pixels_next_to_blue_pixel(output_grid: np.ndarray, blue_pixel: Tuple[int, int], orange_pixels: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"                                                                                                                                                                   \n    Given an output grid, the coordinates of the blue pixel and a list of coordinates of the orange pixels,                                                               \n    moves the orange pixels next to the blue pixel in the output grid.                                                                                                    \n                                                                                                                                                                          \n    Args:                                                                                                                                                                 \n    output_grid: A numpy array representing the output grid.                                                                                                              \n    blue_pixel: A tuple containing the x and y coordinates of the blue pixel in the output grid.                                                                          \n    orange_pixels: A list of tuples containing the x and y coordinates of the orange pixels in the output grid.                                                           \n                                                                                                                                                                          \n    Returns:                                                                                                                                                              \n    A numpy array representing the output grid with the orange pixels moved next to the blue pixel.                                                                       \n    \"\"\"\n    for i in range(len(orange_pixels)):\n        if blue_pixel[0] == orange_pixels[i][0] and blue_pixel[1] < orange_pixels[i][1]:\n            output_grid[blue_pixel[0]][blue_pixel[1] + 1] = orange\n        elif blue_pixel[0] == orange_pixels[i][0] and blue_pixel[1] > orange_pixels[i][1]:\n            output_grid[blue_pixel[0]][blue_pixel[1] - 1] = orange\n        elif blue_pixel[1] == orange_pixels[i][1] and blue_pixel[0] > orange_pixels[i][0]:\n            output_grid[blue_pixel[0] + 1][blue_pixel[1]] = orange\n        elif blue_pixel[1] == orange_pixels[i][1] and blue_pixel[0] < orange_pixels[i][0]:\n            output_grid[blue_pixel[0] - 1][blue_pixel[1]] = orange\n        output_grid[orange_pixels[i][0]][orange_pixels[i][1]] = black\n    return output_grid\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                   \n    in the input grid, you can see a blue pixel, a red pixel, some orange pixels, some green pixels.\n    the output is the same size of the input grid.\n    to make the output, find the blue pixel, the red pixel, the green pixels, the orange pixels.\n    move the oranges pixels next to the blue\n    move the green pixels next to the orange.                                      \n    \"\"\"\n    output_grid = input_grid.copy()\n    blue_pixel = \"find the blue pixel\"(input_grid)\n    red_pixel = \"find the red pixel\"(input_grid)\n    orange_pixels = \"find the orange pixels\"(input_grid)\n    green_pixels = \"find the green pixels\"(input_grid)\n    output_grid = move_orange_pixels_next_to_blue_pixel(output_grid, blue_pixel, orange_pixels)\n    output_grid = move_green_pixels_next_to_red_pixel(output_grid, red_pixel, green_pixels)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef move_green_pixels_next_to_red_pixel(output_grid: np.ndarray, red_pixel: Tuple[int, int], green_pixels: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"                                                                                                                                                                   \n    Given an output grid, the coordinates of the red pixel and a list of coordinates of the green pixels,                                                                 \n    moves the green pixels next to the red pixel in the output grid.                                                                                                      \n                                                                                                                                                                          \n    Args:                                                                                                                                                                 \n    output_grid: A numpy array representing the output grid.                                                                                                              \n    red_pixel: A tuple containing the x and y coordinates of the red pixel in the output grid.                                                                            \n    green_pixels: A list of tuples containing the x and y coordinates of the green pixels in the output grid.                                                             \n                                                                                                                                                                          \n    Returns:                                                                                                                                                              \n    A numpy array representing the output grid with the green pixels moved next to the red pixel.                                                                         \n    \"\"\"\n    for i in range(len(green_pixels)):\n        if red_pixel[0] == green_pixels[i][0] and red_pixel[1] < green_pixels[i][1]:\n            output_grid[red_pixel[0]][red_pixel[1] + 1] = green\n        elif red_pixel[0] == green_pixels[i][0] and red_pixel[1] > green_pixels[i][1]:\n            output_grid[red_pixel[0]][red_pixel[1] - 1] = green\n        elif red_pixel[1] == green_pixels[i][1] and red_pixel[0] > green_pixels[i][0]:\n            output_grid[red_pixel[0] + 1][red_pixel[1]] = green\n        elif red_pixel[1] == green_pixels[i][1] and red_pixel[0] < green_pixels[i][0]:\n            output_grid[red_pixel[0] - 1][red_pixel[1]] = green\n        output_grid[green_pixels[i][0]][green_pixels[i][1]] = black\n    return output_grid\n\ndef move_orange_pixels_next_to_blue_pixel(output_grid: np.ndarray, blue_pixel: Tuple[int, int], orange_pixels: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"                                                                                                                                                                   \n    Given an output grid, the coordinates of the blue pixel and a list of coordinates of the orange pixels,                                                               \n    moves the orange pixels next to the blue pixel in the output grid.                                                                                                    \n                                                                                                                                                                          \n    Args:                                                                                                                                                                 \n    output_grid: A numpy array representing the output grid.                                                                                                              \n    blue_pixel: A tuple containing the x and y coordinates of the blue pixel in the output grid.                                                                          \n    orange_pixels: A list of tuples containing the x and y coordinates of the orange pixels in the output grid.                                                           \n                                                                                                                                                                          \n    Returns:                                                                                                                                                              \n    A numpy array representing the output grid with the orange pixels moved next to the blue pixel.                                                                       \n    \"\"\"\n    for i in range(len(orange_pixels)):\n        if blue_pixel[0] == orange_pixels[i][0] and blue_pixel[1] < orange_pixels[i][1]:\n            output_grid[blue_pixel[0]][blue_pixel[1] + 1] = orange\n        elif blue_pixel[0] == orange_pixels[i][0] and blue_pixel[1] > orange_pixels[i][1]:\n            output_grid[blue_pixel[0]][blue_pixel[1] - 1] = orange\n        elif blue_pixel[1] == orange_pixels[i][1] and blue_pixel[0] > orange_pixels[i][0]:\n            output_grid[blue_pixel[0] + 1][blue_pixel[1]] = orange\n        elif blue_pixel[1] == orange_pixels[i][1] and blue_pixel[0] < orange_pixels[i][0]:\n            output_grid[blue_pixel[0] - 1][blue_pixel[1]] = orange\n        output_grid[orange_pixels[i][0]][orange_pixels[i][1]] = black\n    return output_grid\n\ndef find_green_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an input grid, returns a list of coordinates of the green pixels in the grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of tuples containing the x and y coordinates of the green pixels in the grid.\n    \"\"\"\n    green_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == green:\n                green_pixels.append((i, j))\n    return green_pixels\n\ndef find_orange_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an input grid, returns a list of coordinates of the orange pixels in the grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of tuples containing the x and y coordinates of the orange pixels in the grid.\n    \"\"\"\n    orange_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == orange:\n                orange_pixels.append((i, j))\n    return orange_pixels\n\ndef find_red_pixel(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Given an input grid, returns the coordinates of the red pixel in the grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A tuple containing the x and y coordinates of the red pixel in the grid.\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                return (i, j)\n\ndef find_blue_pixel(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Given an input grid, returns the coordinates of the blue pixel in the grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A tuple containing the x and y coordinates of the blue pixel in the grid.\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == blue:\n                return (i, j)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                   \n    in the input grid, you can see a blue pixel, a red pixel, some orange pixels, some green pixels.\n    the output is the same size of the input grid.\n    to make the output, find the blue pixel, the red pixel, the green pixels, the orange pixels.\n    move the oranges pixels next to the blue\n    move the green pixels next to the orange.                                      \n    \"\"\"\n    output_grid = input_grid.copy()\n    blue_pixel = find_blue_pixel(input_grid)\n    red_pixel = find_red_pixel(input_grid)\n    orange_pixels = find_orange_pixels(input_grid)\n    green_pixels = find_green_pixels(input_grid)\n    output_grid = move_orange_pixels_next_to_blue_pixel(output_grid, blue_pixel, orange_pixels)\n    output_grid = move_green_pixels_next_to_red_pixel(output_grid, red_pixel, green_pixels)\n    return output_grid"}
{"id": 205, "train_io": {"inputs": [[[0, 2, 0, 0, 0, 0, 0, 0, 0], [2, 2, 1, 0, 0, 0, 0, 0, 0], [0, 1, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0], [0, 0, 3, 1, 0, 0, 0, 0], [0, 3, 3, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 2, 0, 0, 0, 0, 0, 0, 0], [2, 2, 1, 0, 0, 0, 0, 0, 0], [0, 1, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 2, 2, 1, 0, 0], [0, 0, 0, 0, 0, 1, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 3, 1, 0, 0], [0, 0, 0, 3, 3, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0], [0, 0, 3, 1, 0, 0, 0, 0], [0, 3, 3, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": "def find_grey_centered_3x3_area(a: Tuple[int, int, int, int], input_grid: np.ndarray) -> np.ndarray:\n    (x, y) = \"find the grey pixel in the input_grid\"(input_grid)\n    n = \"get index of the 3x3 area whose center pixel is (x,y)\"(x, y)\n    out = \"copy area a to area n in the input_grid\"(input_grid, a, n)\n    return out\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    p = \"find all not black and not grey pixels\"(input_grid)\n    a = \"find the 3x3 area in the input_grid which could cover all pixels in p\"(input_grid, p)\n    out = find_grey_centered_3x3_area(a, input_grid)\n    return out", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef copy_area_to_new_location(input_grid: np.ndarray, a: Tuple[int, int, int, int], n: List[Tuple[int, int]]) -> np.ndarray:\n    out = np.copy(input_grid)\n    for i, j in n:\n        out[i][j] = input_grid[a[0] + i - n[0][0]][a[2] + j - n[0][1]]\n    return out\n\ndef get_centered_3x3_area_index(x: int, y: int) -> List[Tuple[int, int]]:\n    return [(i, j) for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]\n\ndef find_grey_pixel(input_grid: np.ndarray) -> Tuple[int, int]:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == grey:\n                return (i, j)\n\ndef find_grey_centered_3x3_area(a: Tuple[int, int, int, int], input_grid: np.ndarray) -> np.ndarray:\n    x, y = find_grey_pixel(input_grid)\n    n = get_centered_3x3_area_index(x, y)\n    out = copy_area_to_new_location(input_grid, a, n)\n    return out\n\ndef find_covering_area(input_grid: np.ndarray, p: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    min_i, min_j = input_grid.shape\n    max_i = max_j = 0\n    for i, j in p:\n        min_i = min(min_i, i)\n        max_i = max(max_i, i)\n        min_j = min(min_j, j)\n        max_j = max(max_j, j)\n    return (min_i, max_i + 1, min_j, max_j + 1)\n\ndef find_non_black_grey_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    non_black_grey_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] not in [black, grey]:\n                non_black_grey_pixels.append((i, j))\n    return non_black_grey_pixels\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    p = find_non_black_grey_pixels(input_grid)\n    a = find_covering_area(input_grid, p)\n    out = find_grey_centered_3x3_area(a, input_grid)\n    return out"}
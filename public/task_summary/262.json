{"id": 262, "train_io": {"inputs": [[[6, 0, 6], [0, 6, 6], [6, 0, 6], [4, 0, 4], [0, 4, 4], [4, 0, 4], [8, 8, 8], [8, 0, 8], [8, 8, 8]], [[2, 0, 0, 3, 0, 0, 7, 0, 7, 1, 0, 0], [2, 0, 0, 3, 0, 0, 0, 7, 0, 1, 0, 0], [0, 2, 2, 0, 3, 3, 7, 0, 7, 0, 1, 1]], [[3, 0, 0, 4, 0, 4, 2, 0, 0, 8, 0, 0, 1, 0, 0], [0, 3, 3, 4, 4, 4, 0, 2, 2, 0, 8, 8, 0, 1, 1], [0, 3, 0, 4, 0, 4, 0, 2, 0, 0, 8, 0, 0, 1, 0]], [[0, 7, 7], [7, 7, 0], [7, 0, 7], [3, 0, 0], [0, 3, 3], [3, 0, 0], [2, 0, 0], [0, 2, 2], [2, 0, 0], [8, 0, 0], [0, 8, 8], [8, 0, 0]]], "outputs": [[[8, 8, 8], [8, 0, 8], [8, 8, 8]], [[7, 0, 7], [0, 7, 0], [7, 0, 7]], [[4, 0, 4], [4, 4, 4], [4, 0, 4]], [[0, 7, 7], [7, 7, 0], [7, 0, 7]]]}, "test_io": {"inputs": [[[0, 5, 0], [5, 0, 5], [0, 5, 0], [0, 3, 0], [3, 0, 3], [0, 3, 0], [6, 0, 6], [6, 6, 0], [6, 0, 6], [0, 4, 0], [4, 0, 4], [0, 4, 0], [0, 8, 0], [8, 0, 8], [0, 8, 0]]], "outputs": [[[6, 0, 6], [6, 6, 0], [6, 0, 6]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    sub_grids = \"divide the input into several 3*3 grid\"(input_grid)\n    output_grid = \"each 3*3 grid has several non-black pixels, output the 3*3 grid that has the most non-black pixels\"(sub_grids)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_grid_with_most_non_black_pixels(sub_grids: List[np.ndarray]) -> np.ndarray:\n    max_non_black_pixels = -1\n    max_non_black_pixels_grid = None\n    for sub_grid in sub_grids:\n        non_black_pixels = np.count_nonzero(sub_grid != black)\n        if non_black_pixels > max_non_black_pixels:\n            max_non_black_pixels = non_black_pixels\n            max_non_black_pixels_grid = sub_grid\n    return max_non_black_pixels_grid\n\ndef divide_into_sub_grids(input_grid: np.ndarray) -> List[np.ndarray]:\n    sub_grids = []\n    for i in range(0, input_grid.shape[0], 3):\n        for j in range(0, input_grid.shape[1], 3):\n            sub_grid = input_grid[i:i + 3, j:j + 3]\n            sub_grids.append(sub_grid)\n    return sub_grids\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    sub_grids = divide_into_sub_grids(input_grid)\n    output_grid = find_grid_with_most_non_black_pixels(sub_grids)\n    return output_grid"}
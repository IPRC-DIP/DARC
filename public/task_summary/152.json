{"id": 152, "train_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 7]], [[0, 0, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 4, 4], [0, 0, 0, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]]], "outputs": [[[3, 3, 7], [3, 7, 7], [3, 7, 7]], [[6, 6, 6], [4, 6, 6], [4, 4, 6]], [[1, 1, 1], [1, 3, 1], [3, 3, 3]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[8, 8, 2], [8, 2, 2], [8, 8, 8]]]}, "solved": true, "generalizable": false, "anpl": "def copy_color1_points(input_grid: np.ndarray, output: np.ndarray, color1: int) -> None:\n    color1_points = np.where(input_grid == color1)\n    minx = min(color1_points[0])\n    miny = min(color1_points[1])\n    for i in range(3):\n        for j in range(3):\n            if input_grid[minx + i][miny + j] == color1:\n                output[i][j] = color1\n\ndef get_non_black_colors(input_grid: np.ndarray) -> Tuple[int, int]:\n    colors_set = set(input_grid.flatten()) - {black}\n    colors = tuple(colors_set)\n    c1 = colors[0]\n    num1 = np.sum(input_grid == c1)\n    c2 = colors[1]\n    num2 = np.sum(input_grid == c2)\n    if num1 > num2:\n        return (colors[0], colors[1])\n    else:\n        return (colors[1], colors[0])\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output = np.zeros((3, 3), dtype=int)\n    (color1, color2) = get_non_black_colors(input_grid)\n    copy_color1_points(input_grid, output, color1)\n    \"Color all black points color2\"(output, color2)\n    return output", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_black_points(input_grid: np.ndarray, color2: int) -> None:\n    \"\"\"\n    This function colors all the black points in the input grid with the color2 value.\n\n    Args:\n    input_grid: A numpy array of shape (3, 3) containing integers from 0 to 9.\n    color2: An integer representing the color to be used for coloring the black points.\n\n    Returns:\n    None\n    \"\"\"\n    for i in range(3):\n        for j in range(3):\n            if input_grid[i][j] == black:\n                input_grid[i][j] = color2\n\ndef copy_color1_points(input_grid: np.ndarray, output: np.ndarray, color1: int) -> None:\n    color1_points = np.where(input_grid == color1)\n    minx = min(color1_points[0])\n    miny = min(color1_points[1])\n    for i in range(3):\n        for j in range(3):\n            if input_grid[minx + i][miny + j] == color1:\n                output[i][j] = color1\n\ndef get_non_black_colors(input_grid: np.ndarray) -> Tuple[int, int]:\n    colors_set = set(input_grid.flatten()) - {black}\n    colors = tuple(colors_set)\n    c1 = colors[0]\n    num1 = np.sum(input_grid == c1)\n    c2 = colors[1]\n    num2 = np.sum(input_grid == c2)\n    if num1 > num2:\n        return (colors[0], colors[1])\n    else:\n        return (colors[1], colors[0])\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output = np.zeros((3, 3), dtype=int)\n    color1, color2 = get_non_black_colors(input_grid)\n    copy_color1_points(input_grid, output, color1)\n    color_black_points(output, color2)\n    return output"}
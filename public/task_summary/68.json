{"id": 68, "train_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 6, 0, 0, 0, 0, 0, 0, 0], [0, 9, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 6, 6, 6, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 6, 0, 0, 0], [0, 0, 0, 0, 0, 9, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 6, 0, 0, 0, 0, 0, 0], [0, 0, 9, 4, 0, 0, 0, 0, 7, 6], [0, 0, 0, 0, 0, 0, 0, 0, 9, 4]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 0, 0, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 0, 8, 8, 8, 8, 0], [0, 0, 8, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0], [3, 4, 3, 3, 0, 0, 8, 8, 0, 0], [0, 0, 3, 0, 0, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 4, 4, 0, 0], [3, 4, 3, 3, 0, 3, 4, 3, 3, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 0, 3, 4, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    ans_grid = \"Generate a new grid, exactly the same as input_grid. Blacken all the teal pixels\"(input_grid)\n    (minx, miny, maxx, maxy) = \"Define four variables (minx, miny, maxx, maxy) as the smallest x, the smallest y, the largest x, and the largest y. Traverse all the pixels in the new grid, if a pixel (x, y) is not black, use the pixel to update the above four variables\"(ans_grid)\n    target_grid = \"Extract the subgrid with (minx, miny) as the upper left corner and (maxx, maxy) as the lower right corner, and return the grid\"(ans_grid, minx, miny, maxx, maxy)\n    mask_grid = \"Generate a new grid with the same size as the target_grid. If the pixel in the subgrid is non-black, the value in the new grid is teal; otherwise, it is black\"(target_grid)\n    input_grid[minx:maxx + 1, miny:maxy + 1] = black\n    ans = \"Traverse all the elements in the inputgrid, match each pixel with a grid same as mask_grid, if the current pixel is matched, overwrite the position with a grid same as target_grid\"(input_grid, target_grid, mask_grid)\n    return ans", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef overwrite_pixels(input_grid: np.ndarray, target_grid: np.ndarray, mask_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Traverse all the elements in the input_grid, match each pixel with a grid same as mask_grid, \n    if the current pixel is matched, overwrite the position with a grid same as target_grid\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if np.array_equal(input_grid[i:i + mask_grid.shape[0], j:j + mask_grid.shape[1]], mask_grid):\n                input_grid[i:i + target_grid.shape[0], j:j + target_grid.shape[1]] = target_grid\n    return input_grid\n\ndef generate_teal_mask(target_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Generate a new grid with the same size as the target_grid. If the pixel in the subgrid is non-black, the value in the new grid is teal; otherwise, it is black\n    \"\"\"\n    return np.where(target_grid != black, teal, black)\n\ndef extract_subgrid(grid: np.ndarray, minx: int, miny: int, maxx: int, maxy: int) -> np.ndarray:\n    \"\"\"\n    Extract the subgrid with (minx, miny) as the upper left corner and (maxx, maxy) as the lower right corner, and return the grid\n    \"\"\"\n    return grid[minx:maxx + 1, miny:maxy + 1]\n\ndef find_bounding_box(grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Define four variables (minx, miny, maxx, maxy) as the smallest x, the smallest y, the largest x, and the largest y. \n    Traverse all the pixels in the new grid, if a pixel (x, y) is not black, use the pixel to update the above four variables\n    \"\"\"\n    minx, miny, maxx, maxy = (float('inf'), float('inf'), -float('inf'), -float('inf'))\n    for x in range(grid.shape[0]):\n        for y in range(grid.shape[1]):\n            if grid[x, y] != black:\n                minx = min(minx, x)\n                miny = min(miny, y)\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n    return (minx, miny, maxx, maxy)\n\ndef blacken_teal_pixels(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Generate a new grid, exactly the same as input_grid. Blacken all the teal pixels.\n    \"\"\"\n    return np.where(input_grid == teal, black, input_grid)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    ans_grid = blacken_teal_pixels(input_grid)\n    minx, miny, maxx, maxy = find_bounding_box(ans_grid)\n    target_grid = extract_subgrid(ans_grid, minx, miny, maxx, maxy)\n    mask_grid = generate_teal_mask(target_grid)\n    input_grid[minx:maxx + 1, miny:maxy + 1] = black\n    ans = overwrite_pixels(input_grid, target_grid, mask_grid)\n    return ans"}
{"id": 343, "train_io": {"inputs": [[[3, 2, 0], [0, 0, 0], [0, 5, 0]], [[5, 0, 0, 0, 0, 0], [0, 0, 3, 2, 0, 0], [0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 2], [0, 2, 0, 0, 0, 0], [5, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 2, 0], [3, 0, 0, 0, 0, 0, 3], [5, 0, 2, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0], [3, 2, 0, 0, 0, 3, 0], [0, 0, 0, 5, 0, 0, 0]]], "outputs": [[[8, 0, 0], [0, 0, 0], [0, 5, 0]], [[5, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0], [5, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 2, 0], [3, 0, 0, 0, 0, 0, 3], [5, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 8, 0], [0, 0, 0, 5, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 2, 0, 0, 0, 5], [0, 2, 0, 0, 0, 0, 3, 2, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 2], [5, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0], [5, 3, 0, 0, 0, 5, 0, 2, 0]]], "outputs": [[[0, 0, 0, 0, 2, 0, 0, 0, 5], [0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 2], [5, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0], [5, 3, 0, 0, 0, 5, 0, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": null, "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef get_adjacent_points(i: int, j: int, rows: int, cols: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes in the row and column indices of a point in a grid and returns a list of tuples representing the row and column indices of its adjacent points.\n    \n    Args:\n    - i: An integer representing the row index of the point.\n    - j: An integer representing the column index of the point.\n    - rows: An integer representing the number of rows in the grid.\n    - cols: An integer representing the number of columns in the grid.\n    \n    Returns:\n    - adjacent_points: A list of tuples representing the row and column indices of the adjacent points.\n    \"\"\"\n    adjacent_points = []\n    if i > 0:\n        adjacent_points.append((i - 1, j))\n    if i < rows - 1:\n        adjacent_points.append((i + 1, j))\n    if j > 0:\n        adjacent_points.append((i, j - 1))\n    if j < cols - 1:\n        adjacent_points.append((i, j + 1))\n    return adjacent_points\n\ndef process_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes in a numpy array representing a grid of colors and processes it according to the following rules:\n    - For every red point in the grid, if it has green adjacent points, turn that green adjacent point to teal and turn the red point to black.\n    - Return the processed grid.\n    \n    Args:\n    - input_grid: A numpy array representing a grid of colors. Each element in the array is an integer representing a color.\n    \n    Returns:\n    - output_grid: A numpy array representing the processed grid of colors.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] == red:\n                adjacent_points = get_adjacent_points(i, j, rows, cols)\n                for point in adjacent_points:\n                    if input_grid[point[0]][point[1]] == green:\n                        output_grid[point[0]][point[1]] = teal\n                        output_grid[i][j] = black\n    return output_grid\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = process_grid(input_grid)\n    return output_grid"}
{"id": 114, "train_io": {"inputs": [[[4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 8, 8], [4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 8, 8, 8, 8], [4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 8, 8, 8, 8], [4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 8, 8, 8, 8], [4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8], [4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8], [4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 8, 8, 8, 8], [4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 8, 8, 8], [4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8], [4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8], [4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8], [4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8], [4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8], [4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8]], [[2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2], [2, 8, 8, 8, 2, 2, 8], [8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 5, 5, 8, 8], [5, 8, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5]], [[6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 4, 4, 6, 6, 6, 6, 6], [6, 4, 4, 4, 6, 4, 6, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 2, 2, 4, 4, 4, 2, 2, 4], [2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 3, 2, 2, 2, 2, 2, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3]]], "outputs": [[[4, 2, 8]], [[2], [8], [5]], [[6], [4], [2], [3]]]}, "test_io": {"inputs": [[[3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 8, 8], [3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 8, 8, 8], [3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 8, 8, 8, 8], [3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 8, 8, 8], [3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 8, 8], [3, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 8], [3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 8, 8], [3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 8, 8, 8], [3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 8, 8], [3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 8, 8], [3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 8, 8, 8], [3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 8, 8], [3, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 8, 8], [3, 3, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 8, 8]]], "outputs": [[[3, 2, 1, 8]]]}, "solved": true, "generalizable": false, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    cnt = \"Count the color types in input_grid,return the number of color kind\"(input_grid)\n    target_line = \"If the number of colors in the first row is equal to cnt, return the first row; otherwise, return the first column\"(input_grid, cnt)\n    ans_grid = \"Remove the repeated color in targetline and arranged in order of appearance of colors, and return the deduplicated array\"(target_line)\n    if len(ans_grid.shape) == 1:\n        ans_grid = np.expand_dims(ans_grid, axis=0)\n    return ans_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef deduplicate_and_arrange(target_line: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes in a numpy array representing a target line of colored pixels and removes any repeated colors, \n    then arranges the colors in the order of their appearance in the original target line.\n\n    Args:\n    - target_line (np.ndarray): A numpy array representing a target line of colored pixels.\n\n    Returns:\n    - deduplicated (np.ndarray): The deduplicated and arranged target line.\n    \"\"\"\n    deduplicated = []\n    for color in target_line:\n        if color not in deduplicated:\n            deduplicated.append(color)\n    deduplicated = np.array(deduplicated)\n    return deduplicated\n\ndef get_target_line(input_grid: np.ndarray, cnt: int) -> np.ndarray:\n    \"\"\"\n    This function takes in a numpy array representing a grid of colored pixels and the number of unique colors present in the grid.\n    If the number of colors in the first row is equal to cnt, return the first row; otherwise, return the first column.\n\n    Args:\n    - input_grid (np.ndarray): A numpy array representing a grid of colored pixels.\n    - cnt (int): The number of unique colors present in the grid.\n\n    Returns:\n    - target_line (np.ndarray): The target line of the input grid.\n    \"\"\"\n    if len(input_grid) > 0:\n        first_row = input_grid[0]\n        if len(np.unique(first_row)) == cnt:\n            target_line = first_row\n        else:\n            target_line = input_grid[:, 0]\n    else:\n        target_line = np.array([])\n    return target_line\n\ndef count_color_types(input_grid: np.ndarray) -> int:\n    \"\"\"\n    This function takes in a numpy array representing a grid of colored pixels and returns the number of unique colors present in the grid.\n\n    Args:\n    - input_grid (np.ndarray): A numpy array representing a grid of colored pixels.\n\n    Returns:\n    - cnt (int): The number of unique colors present in the grid.\n    \"\"\"\n    cnt = len(np.unique(input_grid))\n    return cnt\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    cnt = count_color_types(input_grid)\n    target_line = get_target_line(input_grid, cnt)\n    ans_grid = deduplicate_and_arrange(target_line)\n    if len(ans_grid.shape) == 1:\n        ans_grid = np.expand_dims(ans_grid, axis=0)\n    return ans_grid"}
{"id": 303, "train_io": {"inputs": [[[3, 8, 7], [9, 3, 8], [7, 9, 3]], [[8, 6, 8], [3, 3, 8], [8, 8, 8]], [[6, 9, 9], [4, 6, 8], [9, 9, 8]]], "outputs": [[[3, 8, 7, 0, 0, 0, 0, 0, 0], [9, 3, 8, 0, 0, 0, 0, 0, 0], [7, 9, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 8, 7, 0, 0, 0], [0, 0, 0, 9, 3, 8, 0, 0, 0], [0, 0, 0, 7, 9, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 8, 7], [0, 0, 0, 0, 0, 0, 9, 3, 8], [0, 0, 0, 0, 0, 0, 7, 9, 3]], [[8, 6, 8, 0, 0, 0, 8, 6, 8], [3, 3, 8, 0, 0, 0, 3, 3, 8], [8, 8, 8, 0, 0, 0, 8, 8, 8], [0, 0, 0, 0, 0, 0, 8, 6, 8], [0, 0, 0, 0, 0, 0, 3, 3, 8], [0, 0, 0, 0, 0, 0, 8, 8, 8], [8, 6, 8, 8, 6, 8, 8, 6, 8], [3, 3, 8, 3, 3, 8, 3, 3, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8]], [[0, 0, 0, 6, 9, 9, 6, 9, 9], [0, 0, 0, 4, 6, 8, 4, 6, 8], [0, 0, 0, 9, 9, 8, 9, 9, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 9, 9, 6, 9, 9, 0, 0, 0], [4, 6, 8, 4, 6, 8, 0, 0, 0], [9, 9, 8, 9, 9, 8, 0, 0, 0]]]}, "test_io": {"inputs": [[[1, 1, 7], [7, 4, 1], [5, 1, 7]]], "outputs": [[[1, 1, 7, 1, 1, 7, 0, 0, 0], [7, 4, 1, 7, 4, 1, 0, 0, 0], [5, 1, 7, 5, 1, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 7], [0, 0, 0, 0, 0, 0, 7, 4, 1], [0, 0, 0, 0, 0, 0, 5, 1, 7], [0, 0, 0, 1, 1, 7, 0, 0, 0], [0, 0, 0, 7, 4, 1, 0, 0, 0], [0, 0, 0, 5, 1, 7, 0, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": "import numpy as np\nfrom typing import *\n(black, blue, red, green, yellow, grey, pink, orange, teal, maroon) = range(10)\n\ndef generate_new_grid(input_grid: np.ndarray, mcolor: int) -> np.ndarray:\n    \"\"\"\n    This function generates a new grid based on the input grid and the most common color.\n    It traverses the input grid, and if the pixel (x, y) color is mcolor, then it uses (3*x, 3*y) as the upper left corn\n\n    Args:\n    input_grid: A numpy array representing the input grid\n    mcolor: An integer representing the most common color in the input grid\n\n    Returns:\n    A numpy array representing the new grid\n    \"\"\"\n    new_grid = np.zeros((input_grid.shape[0] * 3, input_grid.shape[1] * 3))\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == mcolor:\n                new_grid[3 * i:3 * i + 3, 3 * j:3 * j + 3] = input_grid\n    return new_grid\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    mcolor = `Count and return the color with the most occurrences in the inputgrid`(input_grid)\n    ans_grid = generate_new_grid(input_grid, mcolor)\n    return ans_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef generate_new_grid(input_grid: np.ndarray, mcolor: int) -> np.ndarray:\n    \"\"\"\n    This function generates a new grid based on the input grid and the most common color.\n    It traverses the input grid, and if the pixel (x, y) color is mcolor, then it uses (3*x, 3*y) as the upper left corn\n\n    Args:\n    input_grid: A numpy array representing the input grid\n    mcolor: An integer representing the most common color in the input grid\n\n    Returns:\n    A numpy array representing the new grid\n    \"\"\"\n    new_grid = np.zeros((input_grid.shape[0] * 3, input_grid.shape[1] * 3))\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == mcolor:\n                new_grid[3 * i:3 * i + 3, 3 * j:3 * j + 3] = input_grid\n    return new_grid\n\ndef get_most_common_color(input_grid: np.ndarray) -> int:\n    \"\"\"\n    This function takes an input grid and returns the color with the most occurrences in the grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    An integer representing the color with the most occurrences in the input grid.\n    \"\"\"\n    color_counts = np.bincount(input_grid.flatten())\n    return np.argmax(color_counts)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    mcolor = get_most_common_color(input_grid)\n    ans_grid = generate_new_grid(input_grid, mcolor)\n    return ans_grid"}
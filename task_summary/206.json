{"id": 206, "train_io": {"inputs": [[[0, 2, 0, 0, 2], [2, 2, 0, 2, 2], [0, 0, 0, 0, 0], [0, 2, 0, 2, 2], [2, 2, 0, 2, 0]], [[1, 0, 0, 1, 0], [0, 1, 0, 0, 1], [0, 0, 0, 0, 0], [1, 0, 0, 1, 0], [1, 1, 0, 0, 1]], [[8, 8, 0, 0, 8], [8, 0, 0, 8, 0], [0, 0, 0, 0, 0], [8, 8, 0, 8, 8], [8, 0, 0, 8, 0]]], "outputs": [[[2, 2], [2, 0]], [[1, 0], [1, 1]], [[0, 8], [8, 0]]]}, "test_io": {"inputs": [[[5, 5, 0, 5, 0], [0, 5, 0, 0, 5], [0, 0, 0, 0, 0], [5, 5, 0, 5, 5], [0, 5, 0, 0, 5]]], "outputs": [[[5, 0], [0, 5]]]}, "solved": true, "generalizable": false, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    sub_grid_list = \"The input grid is 5*5, and the third row and the third column are used as the dividing line to divide the grid into four 2*2 sub-grids, and return a list of four sub-grids\"(input_grid)\n    count_list = \"Count the number of non-black blocks in each sub-grid and return the answer list\"(sub_grid_list)\n    ans_grid = \"Traversing count_list, if one of the values is different from the other three values, return the subgrid corresponding to the value\"(sub_grid_list, count_list)\n    return ans_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef get_different_subgrid(sub_grid_list: List[np.ndarray], count_list: List[int]) -> np.ndarray:\n    \"\"\"\n    Traverses count_list, if one of the values is different from the other three values, returns the sub-grid corresponding to the value.\n    \n    Args:\n    sub_grid_list: A list of four numpy arrays representing the four sub-grids.\n    count_list: A list of four integers representing the number of non-black blocks in each sub-grid.\n    \n    Returns:\n    A numpy array representing the sub-grid with a different number of non-black blocks.\n    \"\"\"\n    for i in range(4):\n        if count_list.count(count_list[i]) == 1:\n            return sub_grid_list[i]\n\ndef count_non_black_blocks(sub_grid_list: List[np.ndarray]) -> List[int]:\n    \"\"\"\n    Counts the number of non-black blocks in each sub-grid and returns the answer list.\n    \n    Args:\n    sub_grid_list: A list of four numpy arrays representing the four sub-grids.\n    \n    Returns:\n    A list of four integers representing the number of non-black blocks in each sub-grid.\n    \"\"\"\n    count_list = []\n    for sub_grid in sub_grid_list:\n        count = np.count_nonzero(sub_grid != black)\n        count_list.append(count)\n    return count_list\n\ndef divide_grid(input_grid: np.ndarray) -> List[np.ndarray]:\n    \"\"\"\n    Divides the input grid into four 2*2 sub-grids using the third row and the third column as the dividing line.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of four numpy arrays representing the four sub-grids.\n    \"\"\"\n    sub_grid_list = []\n    sub_grid_list.append(input_grid[:2, :2])\n    sub_grid_list.append(input_grid[:2, 3:])\n    sub_grid_list.append(input_grid[3:, :2])\n    sub_grid_list.append(input_grid[3:, 3:])\n    return sub_grid_list\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    sub_grid_list = divide_grid(input_grid)\n    count_list = count_non_black_blocks(sub_grid_list)\n    ans_grid = get_different_subgrid(sub_grid_list, count_list)\n    return ans_grid"}
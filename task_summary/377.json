{"id": 377, "train_io": {"inputs": [[[3, 3, 0, 9, 0, 0], [3, 3, 0, 9, 0, 0], [0, 0, 0, 9, 0, 0], [9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], [[0, 0, 8, 0, 6, 0, 8, 0], [0, 0, 8, 0, 0, 0, 8, 0], [0, 0, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0], [0, 4, 0, 2, 2, 0, 4, 0, 0], [0, 4, 0, 2, 2, 0, 4, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0]]], "outputs": [[[3, 3, 0, 9, 0, 0], [3, 3, 0, 9, 0, 0], [0, 0, 0, 9, 0, 0], [9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 3]], [[0, 0, 8, 0, 6, 0, 8, 0], [0, 0, 8, 0, 0, 0, 8, 0], [0, 0, 8, 8, 8, 8, 8, 0], [0, 6, 0, 0, 0, 0, 0, 6], [6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 0, 0, 0, 0, 0, 2, 0], [0, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0], [0, 4, 0, 2, 2, 0, 4, 0, 0], [0, 4, 0, 2, 2, 0, 4, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 3, 0, 4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 3, 0, 4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": null, "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef inside_grid(grid: np.ndarray, coordinate: Tuple[int, int]) -> bool:\n    x, y = coordinate\n    return 0 <= x < grid.shape[0] and 0 <= y < grid.shape[1]\n\ndef draw_diagonal_line_after_meeting_color(grid, line_color, other_color, start_coordinate, direction):\n    x, y = start_coordinate\n    has_meet = False\n    while inside_grid(grid, start_coordinate):\n        if grid[x][y] == black and has_meet:\n            grid[x][y] = line_color\n        elif grid[x][y] == other_color:\n            has_meet = True\n        x += direction[0]\n        y += direction[1]\n        start_coordinate = (x, y)\n\ndef find_rectangle_corners(grid: np.ndarray, color: int) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int], Tuple[int, int]]:\n    x, y = np.where(grid == color)\n    left, top = (np.min(y), np.min(x))\n    right, bottom = (np.max(y), np.max(x))\n    return ((top, left), (bottom, left), (top, right), (bottom, right))\n\ndef is_color_area_rectangle(color: int, grid: np.ndarray) -> bool:\n    x, y = np.where(grid == color)\n    if len(x) == 0:\n        return False\n    left, top = (np.min(y), np.min(x))\n    right, bottom = (np.max(y), np.max(x))\n    return np.all(grid[top:bottom + 1, left:right + 1] == color)\n\ndef find_all_colors_except_black(input_grid: np.ndarray) -> Tuple[int, int]:\n    colors = set(np.unique(input_grid))\n    colors.discard(black)\n    return tuple(colors)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    color1, color2 = find_all_colors_except_black(input_grid)\n    if is_color_area_rectangle(color1, input_grid):\n        rectangle_color, other_color = (color1, color2)\n    else:\n        rectangle_color, other_color = (color2, color1)\n    left_top, left_bottom, right_top, right_bottom = find_rectangle_corners(input_grid, rectangle_color)\n    draw_diagonal_line_after_meeting_color(input_grid, rectangle_color, other_color, left_top, (-1, -1))\n    draw_diagonal_line_after_meeting_color(input_grid, rectangle_color, other_color, left_bottom, (1, -1))\n    draw_diagonal_line_after_meeting_color(input_grid, rectangle_color, other_color, right_top, (-1, 1))\n    draw_diagonal_line_after_meeting_color(input_grid, rectangle_color, other_color, right_bottom, (1, 1))\n    return input_grid"}
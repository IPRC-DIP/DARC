{"id": 335, "train_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0, 0], [0, 0, 5, 5, 5, 0, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 0, 5, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 8, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 8, 5, 0, 0], [0, 0, 5, 5, 5, 8, 5, 5, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 5, 5, 5, 8, 5, 5, 0, 0], [0, 0, 5, 8, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 8, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0, 0], [0, 0, 5, 8, 8, 8, 8, 8, 8, 8], [0, 0, 5, 8, 8, 8, 5, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "solved": true, "generalizable": false, "anpl": "import numpy as np\nfrom typing import *\n(black, blue, red, green, yellow, grey, pink, orange, teal, maroon) = range(10)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    out = `Find the smallest matrix with all grey pixels in the input grid, replace all black pixels inside it(excluding boundaries) with teal`(input_grid)\n    flag = `Return whether there is a row that contains only one gray pixel`(out)\n    if flag:\n        r = `Return the row containing only one grey pixel`(out)\n        flag2 = `Return whether the pixel to the right of the gray pixel in row r is black`(out, r)\n        if flag2:\n            out = `Replace all black pixels to the left of the grey pixel in row r with teal`(out, r)\n        else:\n            out = `Replace all black pixels to the right of the grey pixel in row r with teal`(out, r)\n    else:\n        c = `Return the column containing only one grey pixel`(out)\n        flag2 = `Return whether the pixel above the gray pixel in column c is black`(out, c)\n        if flag2:\n            out = `Replace all black pixels below the grey pixel in column c with teal`(out, c)\n        else:\n            out = `Replace all black pixels above the grey pixel in column c with teal`(out, c)\n    return out", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_above_black_with_teal(grid: np.ndarray, c: int) -> np.ndarray:\n    \"\"\"\n    This function replaces all black pixels above the grey pixel in column c with teal.\n    \n    Args:\n    grid: A numpy array representing the input grid\n    c: An integer value indicating the index of the column with only one grey pixel\n    \n    Returns:\n    A numpy array representing the modified grid\n    \"\"\"\n    grey_pixels = np.where(grid == grey)\n    row = grey_pixels[0][np.where(grey_pixels[1] == c)][0]\n    grid[:row, c][grid[:row, c] == black] = teal\n    return grid\n\ndef replace_below_black_with_teal(grid: np.ndarray, c: int) -> np.ndarray:\n    \"\"\"\n    This function replaces all black pixels below the grey pixel in column c with teal.\n    \n    Args:\n    grid: A numpy array representing the input grid\n    c: An integer value indicating the index of the column with only one grey pixel\n    \n    Returns:\n    A numpy array representing the modified grid\n    \"\"\"\n    grey_pixels = np.where(grid == grey)\n    row = grey_pixels[0][np.where(grey_pixels[1] == c)][0]\n    grid[row + 1:, c][grid[row + 1:, c] == black] = teal\n    return grid\n\ndef is_pixel_above_black(grid: np.ndarray, c: int, r: int) -> bool:\n    \"\"\"\n    This function checks if the pixel above the gray pixel in column c and row r is black.\n    \n    Args:\n    grid: A numpy array representing the input grid\n    c: An integer value indicating the index of the column with only one grey pixel\n    r: An integer value indicating the index of the row with only one grey pixel\n    \n    Returns:\n    A boolean value indicating whether the pixel above the gray pixel in column c and row r is black\n    \"\"\"\n    if r > 0 and grid[r - 1, c] == black:\n        return True\n    return False\n\ndef get_single_grey_column(grid: np.ndarray) -> Optional[int]:\n    \"\"\"\n    This function returns the index of the column that contains only one grey pixel.\n    \n    Args:\n    grid: A numpy array representing the input grid\n    \n    Returns:\n    An integer value indicating the index of the column with only one grey pixel. If no such column exists, returns None.\n    \"\"\"\n    for i, col in enumerate(grid.T):\n        if np.count_nonzero(col == grey) == 1:\n            return i\n    return None\n\ndef replace_right_black_with_teal(grid: np.ndarray, r: int) -> np.ndarray:\n    \"\"\"\n    This function replaces all black pixels to the right of the grey pixel in row r with teal.\n    \n    Args:\n    grid: A numpy array representing the input grid\n    r: An integer value indicating the index of the row with only one grey pixel\n    \n    Returns:\n    A numpy array representing the modified grid\n    \"\"\"\n    grey_pixels = np.where(grid == grey)\n    col = grey_pixels[1][np.where(grey_pixels[0] == r)][0]\n    grid[r, col + 1:][grid[r, col + 1:] == black] = teal\n    return grid\n\ndef replace_left_black_with_teal(grid: np.ndarray, r: int) -> np.ndarray:\n    \"\"\"\n    This function replaces all black pixels to the left of the grey pixel in row r with teal.\n    \n    Args:\n    grid: A numpy array representing the input grid\n    r: An integer value indicating the index of the row with only one grey pixel\n    \n    Returns:\n    A numpy array representing the modified grid\n    \"\"\"\n    grey_pixels = np.where(grid == grey)\n    col = grey_pixels[1][np.where(grey_pixels[0] == r)][0]\n    grid[r, :col][grid[r, :col] == black] = teal\n    return grid\n\ndef is_pixel_to_right_black(grid: np.ndarray, r: int) -> bool:\n    \"\"\"\n    This function checks if the pixel to the right of the gray pixel in row r is black.\n    \n    Args:\n    grid: A numpy array representing the input grid\n    r: An integer value indicating the index of the row with only one grey pixel\n    \n    Returns:\n    A boolean value indicating whether the pixel to the right of the gray pixel in row r is black\n    \"\"\"\n    grey_pixels = np.where(grid == grey)\n    col = grey_pixels[1][np.where(grey_pixels[0] == r)][0]\n    if col < grid.shape[1] - 1 and grid[r, col + 1] == black:\n        return True\n    return False\n\ndef get_single_grey_row(grid: np.ndarray) -> Optional[int]:\n    \"\"\"\n    This function returns the index of the row that contains only one grey pixel.\n    \n    Args:\n    grid: A numpy array representing the input grid\n    \n    Returns:\n    An integer value indicating the index of the row with only one grey pixel. If no such row exists, returns None.\n    \"\"\"\n    for i, row in enumerate(grid):\n        if np.count_nonzero(row == grey) == 1:\n            return i\n    return None\n\ndef is_single_grey_row(grid: np.ndarray) -> bool:\n    \"\"\"\n    This function checks if there is a row in the input grid that contains only one grey pixel.\n    \n    Args:\n    grid: A numpy array representing the input grid\n    \n    Returns:\n    A boolean value indicating whether there is a row with only one grey pixel\n    \"\"\"\n    for row in grid:\n        if np.count_nonzero(row == grey) == 1:\n            return True\n    return False\n\ndef find_smallest_matrix(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function finds the smallest matrix with all grey pixels in the input grid, \n    replaces all black pixels inside it (excluding boundaries) with teal, and returns the modified matrix.\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    A numpy array representing the modified grid\n    \"\"\"\n    out = np.copy(input_grid)\n    grey_pixels = np.where(out == grey)\n    min_row, max_row = (np.min(grey_pixels[0]), np.max(grey_pixels[0]))\n    min_col, max_col = (np.min(grey_pixels[1]), np.max(grey_pixels[1]))\n    out[min_row + 1:max_row, min_col + 1:max_col][out[min_row + 1:max_row, min_col + 1:max_col] == black] = teal\n    return out\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    out = find_smallest_matrix(input_grid)\n    flag = is_single_grey_row(out)\n    if flag:\n        r = get_single_grey_row(out)\n        flag2 = is_pixel_to_right_black(out, r)\n        if flag2:\n            out = replace_left_black_with_teal(out, r)\n        else:\n            out = replace_right_black_with_teal(out, r)\n    else:\n        c = get_single_grey_column(out)\n        flag2 = is_pixel_above_black(out, c)\n        if flag2:\n            out = replace_below_black_with_teal(out, c)\n        else:\n            out = replace_above_black_with_teal(out, c)\n    return out"}
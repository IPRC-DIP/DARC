{"id": 250, "train_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 0, 0], [0, 2, 0, 0, 0, 2, 0, 0], [0, 2, 0, 2, 0, 2, 0, 0], [0, 2, 0, 0, 0, 2, 0, 0], [0, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 2, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 2, 0, 0, 0, 2, 0], [0, 0, 2, 0, 2, 0, 2, 0], [0, 0, 2, 0, 0, 0, 2, 0], [0, 0, 2, 2, 2, 2, 2, 0]], [[0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 2, 0, 2, 0, 2, 2, 2, 2, 0], [0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 2, 0], [0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 2, 0], [0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 2, 0], [0, 0, 0, 2, 0, 2, 0, 2, 2, 2, 2, 0], [0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 0, 0], [0, 2, 1, 1, 1, 2, 0, 0], [0, 2, 1, 2, 1, 2, 0, 0], [0, 2, 1, 1, 1, 2, 0, 0], [0, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 2, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 2, 1, 1, 1, 2, 0], [0, 0, 2, 1, 2, 1, 2, 0], [0, 0, 2, 1, 1, 1, 2, 0], [0, 0, 2, 2, 2, 2, 2, 0]], [[0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 2, 1, 1, 1, 2, 0, 0, 0, 0], [0, 0, 0, 2, 1, 2, 1, 2, 2, 2, 2, 0], [0, 0, 0, 2, 1, 1, 1, 2, 1, 1, 2, 0], [0, 0, 0, 2, 2, 2, 2, 2, 1, 1, 2, 0], [0, 0, 0, 2, 1, 1, 1, 2, 1, 1, 2, 0], [0, 0, 0, 2, 1, 2, 1, 2, 2, 2, 2, 0], [0, 0, 0, 2, 1, 1, 1, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2]]]}, "test_io": {"inputs": [[[0, 0, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 0, 0, 0, 2, 0, 0], [0, 0, 2, 0, 0, 0, 2, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0], [2, 0, 0, 0, 2, 0, 0, 0, 0], [2, 0, 2, 0, 2, 0, 0, 0, 0], [2, 0, 0, 0, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0]]], "outputs": [[[0, 0, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 1, 1, 1, 2, 0, 0], [0, 0, 2, 1, 1, 1, 2, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0], [2, 1, 1, 1, 2, 0, 0, 0, 0], [2, 1, 2, 1, 2, 0, 0, 0, 0], [2, 1, 1, 1, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0]]]}, "solved": true, "generalizable": false, "anpl": "def find_blue_pixels_on_top_and_bottom(row: int, col: int, grid: np.ndarray) -> bool:\n    \"\"\"                                                                                                                                                                 \n    Given a row and column index, and a grid, this function returns a boolean value indicating                                                                          \n    whether there is a blue pixel on the top and bottom of the given pixel.                                                                                             \n    \"\"\"\n    up_red_pixel = False\n    down_red_pixel = False\n    for i in range(row - 1, -1, -1):\n        if grid[i][col] == red:\n            up_red_pixel = True\n            break\n    for i in range(row + 1, grid.shape[1]):\n        if grid[i][col] == red:\n            down_red_pixel = True\n            break\n    return (up_red_pixel, down_red_pixel)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see on the black grid, a structure composed by red pixels,                                                                                 \n    color the black pixels that inside the red structure to blue.                                                                                                       \n    \"\"\"\n    output_grid = input_grid.copy()\n    for row in range(output_grid.shape[0]):\n        for col in range(output_grid.shape[1]):\n            if output_grid[row][col] == black:\n                have_pixels_left_right = \"from this pixel, go left and right if meet one red pixel on left, and one red pixel on right\"(row, col, output_grid)\n                have_pixels_up_down = find_blue_pixels_on_top_and_bottom(row, col, output_grid)\n                if have_pixels_left_right[0] and have_pixels_left_right[1] and have_pixels_up_down[0] and have_pixels_up_down[1]:\n                    output_grid[row][col] = blue\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_blue_pixels_on_top_and_bottom(row: int, col: int, grid: np.ndarray) -> bool:\n    \"\"\"                                                                                                                                                                 \n    Given a row and column index, and a grid, this function returns a boolean value indicating                                                                          \n    whether there is a blue pixel on the top and bottom of the given pixel.                                                                                             \n    \"\"\"\n    up_red_pixel = False\n    down_red_pixel = False\n    for i in range(row - 1, -1, -1):\n        if grid[i][col] == red:\n            up_red_pixel = True\n            break\n    for i in range(row + 1, grid.shape[1]):\n        if grid[i][col] == red:\n            down_red_pixel = True\n            break\n    return (up_red_pixel, down_red_pixel)\n\ndef find_red_pixels_on_left_and_right(row: int, col: int, grid: np.ndarray) -> Tuple[bool, bool]:\n    \"\"\"\n    Given a row and column index, and a grid, this function returns a tuple of two boolean values.\n    The first boolean value indicates whether there is a red pixel on the left of the given pixel.\n    The second boolean value indicates whether there is a red pixel on the right of the given pixel.\n    \"\"\"\n    left_red_pixel = False\n    right_red_pixel = False\n    for i in range(col - 1, -1, -1):\n        if grid[row][i] == red:\n            left_red_pixel = True\n            break\n    for i in range(col + 1, grid.shape[1]):\n        if grid[row][i] == red:\n            right_red_pixel = True\n            break\n    return (left_red_pixel, right_red_pixel)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see on the black grid, a structure composed by red pixels,                                                                                 \n    color the black pixels that inside the red structure to blue.                                                                                                       \n    \"\"\"\n    output_grid = input_grid.copy()\n    for row in range(output_grid.shape[0]):\n        for col in range(output_grid.shape[1]):\n            if output_grid[row][col] == black:\n                have_pixels_left_right = find_red_pixels_on_left_and_right(row, col, output_grid)\n                have_pixels_up_down = find_blue_pixels_on_top_and_bottom(row, col, output_grid)\n                if have_pixels_left_right[0] and have_pixels_left_right[1] and have_pixels_up_down[0] and have_pixels_up_down[1]:\n                    output_grid[row][col] = blue\n    return output_grid"}
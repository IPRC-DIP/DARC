{"id": 320, "train_io": {"inputs": [[[0, 4, 0, 4, 2, 9, 9, 0, 0, 2, 0, 0, 0, 0], [0, 4, 0, 0, 2, 0, 0, 9, 9, 2, 0, 1, 0, 0], [4, 0, 0, 0, 2, 0, 0, 0, 0, 2, 1, 1, 1, 0], [4, 4, 4, 4, 2, 9, 0, 9, 0, 2, 1, 1, 0, 1]], [[4, 4, 4, 4, 2, 9, 0, 9, 0, 2, 0, 0, 0, 1], [4, 4, 0, 0, 2, 9, 9, 0, 0, 2, 1, 0, 0, 0], [4, 0, 4, 4, 2, 0, 0, 0, 9, 2, 0, 1, 0, 1], [0, 0, 0, 0, 2, 0, 0, 9, 0, 2, 1, 0, 1, 0]], [[4, 4, 4, 0, 2, 9, 9, 0, 9, 2, 0, 1, 0, 1], [0, 4, 0, 4, 2, 0, 0, 9, 0, 2, 0, 1, 0, 0], [0, 4, 0, 4, 2, 0, 0, 9, 9, 2, 1, 0, 0, 1], [4, 0, 4, 4, 2, 9, 9, 9, 0, 2, 0, 0, 0, 1]], [[0, 0, 0, 4, 2, 0, 0, 0, 9, 2, 0, 0, 0, 0], [4, 4, 0, 4, 2, 9, 0, 9, 0, 2, 0, 0, 0, 0], [4, 0, 4, 4, 2, 0, 9, 9, 0, 2, 1, 1, 0, 1], [0, 4, 4, 4, 2, 0, 9, 0, 0, 2, 1, 1, 1, 1]], [[4, 0, 4, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 1], [4, 4, 4, 4, 2, 0, 0, 0, 9, 2, 1, 1, 0, 0], [0, 4, 4, 4, 2, 0, 9, 9, 0, 2, 1, 1, 0, 1], [0, 4, 4, 0, 2, 0, 0, 9, 0, 2, 0, 1, 0, 1]]], "outputs": [[[9, 4, 0, 4], [0, 4, 9, 9], [4, 1, 1, 0], [4, 4, 4, 4]], [[4, 4, 4, 4], [4, 4, 0, 0], [4, 1, 4, 4], [1, 0, 9, 0]], [[4, 4, 4, 9], [0, 4, 9, 4], [1, 4, 9, 4], [4, 9, 4, 4]], [[0, 0, 0, 4], [4, 4, 9, 4], [4, 9, 4, 4], [1, 4, 4, 4]], [[4, 0, 4, 1], [4, 4, 4, 4], [1, 4, 4, 4], [0, 4, 4, 1]]]}, "test_io": {"inputs": [[[0, 0, 4, 0, 2, 9, 0, 9, 0, 2, 1, 1, 0, 0], [4, 4, 0, 4, 2, 9, 9, 9, 0, 2, 1, 1, 1, 0], [0, 0, 0, 0, 2, 0, 9, 9, 9, 2, 1, 1, 0, 1], [0, 4, 4, 0, 2, 9, 0, 9, 9, 2, 1, 0, 0, 0]]], "outputs": [[[9, 1, 4, 0], [4, 4, 9, 4], [1, 9, 9, 9], [9, 4, 4, 9]]]}, "solved": true, "generalizable": true, "anpl": "import numpy as np\nfrom typing import *\n(black, blue, red, green, yellow, grey, pink, orange, teal, maroon) = range(10)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    input_grid = np.concatenate((input_grid, np.array([[2], [2], [2], [2]])), axis=1)\n    divided_grids = `return the divided grids by the red columns(the divided grid don't contain the dividing columns)`(input_grid)\n    output_grid = np.zeros((4, 4))\n    for grid in divided_grids:\n        output_grid = `copy the non-black pixels in the grid to the output_grid`(output_grid, grid)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef copy_non_black_pixels(output_grid: np.ndarray, grid: np.ndarray) -> np.ndarray:\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if grid[i, j] != black:\n                output_grid[i, j] = grid[i, j]\n    return output_grid\n\ndef divide_grid_by_red_columns(grid: np.ndarray) -> List[np.ndarray]:\n    divided_grids = []\n    start_col = 0\n    for j in range(grid.shape[1]):\n        if np.all(grid[:, j] == red):\n            divided_grids.append(grid[:, start_col:j])\n            start_col = j + 1\n    divided_grids.append(grid[:, start_col:])\n    return divided_grids[:-1][::-1]\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    input_grid = np.concatenate((input_grid, np.array([[2], [2], [2], [2]])), axis=1)\n    divided_grids = divide_grid_by_red_columns(input_grid)\n    output_grid = np.zeros((4, 4))\n    for grid in divided_grids:\n        output_grid = copy_non_black_pixels(output_grid, grid)\n    return output_grid"}
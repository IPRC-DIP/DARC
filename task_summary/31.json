{"id": 31, "train_io": {"inputs": [[[0, 4, 0, 9], [0, 0, 0, 0], [0, 4, 6, 0], [1, 0, 0, 0]], [[0, 0, 0, 0, 0, 9], [0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0], [4, 0, 7, 8, 0, 0], [4, 0, 7, 0, 0, 0]], [[0, 0, 0, 1, 0], [0, 3, 0, 0, 0], [0, 3, 0, 1, 2], [6, 0, 0, 0, 0], [0, 3, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0], [0, 0, 0, 0], [0, 4, 0, 0], [1, 4, 6, 9]], [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0], [4, 0, 7, 8, 0, 0], [4, 0, 7, 8, 0, 9]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 3, 0, 0, 0], [0, 3, 0, 1, 0], [6, 3, 0, 1, 2]]]}, "test_io": {"inputs": [[[0, 2, 0, 4, 3], [5, 0, 0, 0, 0], [0, 0, 6, 0, 0], [5, 2, 0, 4, 0], [5, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [5, 0, 0, 0, 0], [5, 2, 0, 4, 0], [5, 2, 6, 4, 3]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    (y, color) = \"get which columns have pixel which is not black and get its color of each column\"(input_grid)\n    n = \"get the number of the pixels which are not black in each of these columns\"(input_grid, y)\n    output_grid = \"black grid which has the same shape as input\"(input_grid)\n    output_grid = \"for each column in y, change the bottom n pixels to the color\"(output_grid, y, color, n)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_bottom_pixels_to_color(input_grid: np.ndarray, column_indices: List[int], colors: List[int], num_pixels: List[int]) -> np.ndarray:\n    \"\"\"\n    For each column in column_indices, change the bottom num_pixels pixels to the corresponding color in colors.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    column_indices: A list of column indices.\n    colors: A list of colors to be used for changing the pixels.\n    num_pixels: A list of number of pixels to be changed for each column.\n    \n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    output_grid = input_grid.copy()\n    for i, col in enumerate(column_indices):\n        output_grid[-num_pixels[i]:, col] = colors[i]\n    return output_grid\n\ndef create_black_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes an input grid as a numpy array and returns a black grid which has the same shape as the input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array representing a black grid which has the same shape as the input grid.\n    \"\"\"\n    return np.zeros_like(input_grid)\n\ndef get_non_black_pixels_count(input_grid: np.ndarray, column_indices: List[int]) -> List[int]:\n    \"\"\"\n    This function takes an input grid as a numpy array and a list of column indices and returns a list of the number of pixels which are not black in each of these columns.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    column_indices: A list of column indices.\n    \n    Returns:\n    A list of the number of pixels which are not black in each of the columns in the input list.\n    \"\"\"\n    non_black_pixels_count = []\n    for i in column_indices:\n        column = input_grid[:, i]\n        non_black_pixels_count.append(np.count_nonzero(column != black))\n    return non_black_pixels_count\n\ndef get_non_black_columns(input_grid: np.ndarray) -> Tuple[List[int], List[int]]:\n    \"\"\"\n    This function takes an input grid as a numpy array and returns two lists:\n    1. A list of column indices that have at least one non-black pixel.\n    2. A list of colors of the non-black pixels in each of the columns in the first list.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A tuple of two lists. The first list contains the column indices and the second list contains the colors of the non-black pixels in each of the columns in the first list.\n    \"\"\"\n    non_black_columns = []\n    non_black_colors = []\n    for i in range(input_grid.shape[1]):\n        column = input_grid[:, i]\n        if not np.all(column == black):\n            non_black_columns.append(i)\n            non_black_colors.append(column[column != black][0])\n    return (non_black_columns, non_black_colors)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    y, color = get_non_black_columns(input_grid)\n    n = get_non_black_pixels_count(input_grid, y)\n    output_grid = create_black_grid(input_grid)\n    output_grid = change_bottom_pixels_to_color(output_grid, y, color, n)\n    return output_grid"}
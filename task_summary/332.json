{"id": 332, "train_io": {"inputs": [[[1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 1, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]], [[0, 7, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 3, 3, 0, 0, 8], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0, 7]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 1, 1, 1, 1, 1, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 6, 0, 0], [0, 0, 6, 0, 0, 0, 6, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]], [[0, 7, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 7, 7, 3, 3, 8, 8, 8], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0, 0], [0, 8, 0, 0, 0, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 8, 0], [0, 0, 0, 8, 0, 7, 0, 0, 0, 0], [0, 7, 0, 0, 0, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0, 7]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 0, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 6, 0, 6, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [2, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 2, 0, 0], [6, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 6, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [6, 6, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 2, 0, 0], [0, 0, 0, 6, 0, 6, 0, 0, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": "import numpy as np\nfrom typing import *\n(black, blue, red, green, yellow, grey, pink, orange, teal, maroon) = range(10)\n\ndef color_points_between(input_grid: np.ndarray, non_black_point: Tuple[int, int], i: int, j: int) -> None:\n    (x, y) = non_black_point\n    color = input_grid[x, y]\n    if i == x:\n        for k in range(min(j, y), max(j, y)):\n            if input_grid[i, k] == black:\n                input_grid[i, k] = color\n    elif j == y:\n        for k in range(min(i, x), max(i, x)):\n            if input_grid[k, j] == black:\n                input_grid[k, j] = color\n\ndef color_black_points(input_grid: np.ndarray, corner: Tuple[int, int]) -> None:\n    (i, j) = corner\n    row = input_grid[i, :]\n    col = input_grid[:, j]\n    row_non_black = np.where(row != black)[0]\n    col_non_black = np.where(col != black)[0]\n    if len(row_non_black) > 1:\n        non_black_point = (i, row_non_black[0])\n        color_points_between(input_grid, non_black_point, i, j)\n        non_black_point = (i, row_non_black[-1])\n        color_points_between(input_grid, non_black_point, i, j)\n    if len(col_non_black) > 1:\n        non_black_point = (col_non_black[0], j)\n        color_points_between(input_grid, non_black_point, i, j)\n        non_black_point = (col_non_black[-1], j)\n        color_points_between(input_grid, non_black_point, i, j)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    (i, j) = `find the 2*2 green area in the grid, return its left-up coordinate`(input_grid)\n    green_square = [(i, j), (i, j + 1), (i + 1, j), (i + 1, j + 1)]\n    for corner in green_square:\n        color_black_points(input_grid, corner)\n    return input_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_points_between(input_grid: np.ndarray, non_black_point: Tuple[int, int], i: int, j: int) -> None:\n    x, y = non_black_point\n    color = input_grid[x, y]\n    if i == x:\n        for k in range(min(j, y), max(j, y)):\n            if input_grid[i, k] == black:\n                input_grid[i, k] = color\n    elif j == y:\n        for k in range(min(i, x), max(i, x)):\n            if input_grid[k, j] == black:\n                input_grid[k, j] = color\n\ndef color_black_points(input_grid: np.ndarray, corner: Tuple[int, int]) -> None:\n    i, j = corner\n    row = input_grid[i, :]\n    col = input_grid[:, j]\n    row_non_black = np.where(row != black)[0]\n    col_non_black = np.where(col != black)[0]\n    if len(row_non_black) > 1:\n        non_black_point = (i, row_non_black[0])\n        color_points_between(input_grid, non_black_point, i, j)\n        non_black_point = (i, row_non_black[-1])\n        color_points_between(input_grid, non_black_point, i, j)\n    if len(col_non_black) > 1:\n        non_black_point = (col_non_black[0], j)\n        color_points_between(input_grid, non_black_point, i, j)\n        non_black_point = (col_non_black[-1], j)\n        color_points_between(input_grid, non_black_point, i, j)\n\ndef find_green_area(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    This function takes a numpy array as input and returns the left-up coordinate of the 2*2 green area in the grid.\n    \n    Args:\n    input_grid: A numpy array representing the grid.\n    \n    Returns:\n    A tuple of two integers representing the left-up coordinate of the 2*2 green area in the grid.\n    \"\"\"\n    i, j = np.where(input_grid == green)\n    return (i[0], j[0])\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    i, j = find_green_area(input_grid)\n    green_square = [(i, j), (i, j + 1), (i + 1, j), (i + 1, j + 1)]\n    for corner in green_square:\n        color_black_points(input_grid, corner)\n    return input_grid"}
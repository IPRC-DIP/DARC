{"id": 351, "train_io": {"inputs": [[[2, 0, 0, 0, 0], [0, 0, 0, 2, 0], [0, 0, 0, 0, 0], [0, 6, 0, 0, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 2, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]], "outputs": [[[2, 1, 1, 1, 1], [1, 1, 1, 2, 1], [0, 0, 1, 1, 1], [0, 6, 0, 0, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 1, 2], [0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0], [0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 2, 1, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0]], [[1, 1, 1, 0, 0], [1, 2, 1, 0, 0], [1, 1, 1, 0, 0], [0, 0, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5]]], "outputs": [[[0, 1, 1, 1, 0, 0, 0, 0, 7, 0], [0, 1, 2, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 1, 2, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 2, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5]]]}, "solved": true, "generalizable": true, "anpl": "import numpy as np\nfrom typing import *\n(black, blue, red, green, yellow, grey, pink, orange, teal, maroon) = range(10)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    red_grids = `find all red grids in the input and return their positions`(input_grid)\n    output = `find all black grids with legal positions that are adjacent to the red grids(diagonally adjacent included). Color them blue.`(input_grid, red_grids)\n    return output", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_adjacent_black_grids(input_grid: np.ndarray, red_grids: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    This function takes in a numpy array as input_grid and a list of tuples containing the positions of all the red grids in the input as red_grids.\n    It colors all black grids(diagonally adjacent included) that are adjacent to the red grids with blue.\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    red_grids: A list of tuples containing the positions of all the red grids in the input.\n    \n    Returns:\n    A numpy array with the black grids adjacent to the red grids colored blue.\n    \"\"\"\n    blue_grids = []\n    for r, c in red_grids:\n        for i in range(r - 1, r + 2):\n            for j in range(c - 1, c + 2):\n                if i >= 0 and j >= 0 and (i < input_grid.shape[0]) and (j < input_grid.shape[1]) and (input_grid[i][j] == black):\n                    input_grid[i][j] = blue\n                    blue_grids.append((i, j))\n    return input_grid\n\ndef find_red_grids(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes in a numpy array as input_grid and returns a list of tuples containing the positions of all the red grids in the input.\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    A list of tuples containing the positions of all the red grids in the input.\n    \"\"\"\n    red_grids = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                red_grids.append((i, j))\n    return red_grids\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    red_grids = find_red_grids(input_grid)\n    output = color_adjacent_black_grids(input_grid, red_grids)\n    return output"}
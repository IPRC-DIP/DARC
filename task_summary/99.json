{"id": 99, "train_io": {"inputs": [[[0, 7, 7, 7, 7, 0, 0, 0, 0, 0], [0, 7, 0, 0, 7, 0, 0, 0, 0, 0], [0, 7, 0, 0, 7, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[6, 6, 6, 6, 6, 0, 0, 0, 0, 0], [6, 0, 0, 0, 6, 0, 0, 0, 0, 0], [6, 0, 0, 0, 6, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 0, 0, 0, 0, 7, 0, 0], [0, 0, 7, 0, 0, 0, 0, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2]]], "outputs": [[[8, 8], [8, 8]], [[7, 7], [7, 7]], [[4, 4], [4, 4]]]}, "test_io": {"inputs": [[[3, 3, 3, 3, 3, 0, 9, 9, 9, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 3, 3, 3, 3, 0, 9, 0, 0, 9], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9]]], "outputs": [[[3, 3], [3, 3]]]}, "solved": true, "generalizable": true, "anpl": "def find_color_areas(input_grid: np.ndarray, color_list: List[int]) -> List[Tuple[int, int]]:\n    color_areas = []\n    for color in color_list:\n        x_min = \"find the most_left point with the color and save the col\"(input_grid, color)\n        x_max = \"find the most_right point with the color and save the col\"(input_grid, color)\n        y_min = \"find the most_top point with the color and save the row\"(input_grid, color)\n        y_max = \"find the most_bottom point with the color and save the row\"(input_grid, color)\n        area = \"calculate the area-size with top-left and bottom-right\"(x_min, x_max, y_min, y_max)\n        color_areas.append((color, area))\n    return color_areas\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    color_list = \"find all not-black color and output a list\"(input_grid)\n    area_size_list = find_color_areas(input_grid, color_list)\n    output = \"there is a list of tuple. In the tuple, first int is color, second int is the area-size. you should drwa a 2*2 grid Using the color which have biggest area-size\"(area_size_list)\n    return output", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef calculate_area_size(x_min: int, x_max: int, y_min: int, y_max: int) -> int:\n    \"\"\"\n    Given the top-left and bottom-right coordinates of a rectangle, this function calculates the area size.\n\n    Args:\n    x_min: An integer representing the x-coordinate of the top-left corner of the rectangle.\n    x_max: An integer representing the x-coordinate of the bottom-right corner of the rectangle.\n    y_min: An integer representing the y-coordinate of the top-left corner of the rectangle.\n    y_max: An integer representing the y-coordinate of the bottom-right corner of the rectangle.\n\n    Returns:\n    An integer representing the area size of the rectangle.\n    \"\"\"\n    return (x_max - x_min + 1) * (y_max - y_min + 1)\n\ndef find_most_bottom_point(input_grid: np.ndarray, color: int) -> int:\n    for i in range(input_grid.shape[0] - 1, -1, -1):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == color:\n                return i\n    return -1\n\ndef find_most_top_point(input_grid: np.ndarray, color: int) -> int:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == color:\n                return i\n    return -1\n\ndef find_most_right_point(input_grid: np.ndarray, color: int) -> int:\n    for j in range(input_grid.shape[1] - 1, -1, -1):\n        for i in range(input_grid.shape[0]):\n            if input_grid[i][j] == color:\n                return j\n    return -1\n\ndef find_most_left_point(input_grid: np.ndarray, color: int) -> int:\n    for j in range(input_grid.shape[1]):\n        for i in range(input_grid.shape[0]):\n            if input_grid[i][j] == color:\n                return j\n    return -1\n\ndef draw_largest_color_area(area_size_list: List[Tuple[int, int]]) -> np.ndarray:\n    sorted_list = sorted(area_size_list, key=lambda x: x[1], reverse=True)\n    largest_color = sorted_list[0][0]\n    output = np.full((2, 2), largest_color)\n    return output\n\ndef find_color_areas(input_grid: np.ndarray, color_list: List[int]) -> List[Tuple[int, int]]:\n    color_areas = []\n    for color in color_list:\n        x_min = find_most_left_point(input_grid, color)\n        x_max = find_most_right_point(input_grid, color)\n        y_min = find_most_top_point(input_grid, color)\n        y_max = find_most_bottom_point(input_grid, color)\n        area = calculate_area_size(x_min, x_max, y_min, y_max)\n        color_areas.append((color, area))\n    return color_areas\n\ndef find_not_black_colors(input_grid: np.ndarray) -> List[int]:\n    \"\"\"\n    Given an input grid, this function returns a list of all the non-black colors present in the grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A list of integers representing the non-black colors present in the grid.\n    \"\"\"\n    color_list = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black and input_grid[i][j] not in color_list:\n                color_list.append(input_grid[i][j])\n    return color_list\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    color_list = find_not_black_colors(input_grid)\n    area_size_list = find_color_areas(input_grid, color_list)\n    output = draw_largest_color_area(area_size_list)\n    return output"}
{"id": 368, "train_io": {"inputs": [[[5, 5, 5, 5, 0, 5, 5, 5, 0, 5], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5], [0, 5, 5, 5, 5, 5, 0, 0, 5, 0], [5, 5, 0, 5, 5, 5, 5, 0, 5, 0], [5, 5, 5, 5, 0, 0, 5, 5, 5, 5], [0, 5, 0, 5, 5, 5, 5, 0, 5, 0], [0, 5, 5, 5, 0, 0, 5, 5, 5, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 0, 5, 0]], [[5, 5, 5, 5, 5, 0, 0, 5, 5, 5], [0, 0, 5, 0, 5, 5, 5, 5, 5, 0], [5, 5, 5, 5, 5, 0, 5, 0, 0, 5], [5, 0, 5, 5, 5, 0, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 0, 5], [5, 5, 5, 5, 0, 5, 5, 5, 5, 5], [0, 0, 5, 5, 0, 5, 0, 0, 5, 0], [5, 5, 5, 5, 5, 5, 5, 0, 5, 5], [0, 5, 5, 5, 5, 5, 0, 5, 5, 0], [0, 0, 5, 5, 5, 5, 5, 5, 0, 5]], [[0, 0, 5, 5, 0, 5, 5, 5, 0, 5], [5, 5, 0, 0, 5, 5, 5, 5, 0, 5], [5, 0, 5, 0, 5, 0, 5, 5, 0, 5], [5, 0, 5, 5, 0, 5, 5, 5, 5, 5], [5, 5, 5, 0, 0, 5, 5, 0, 5, 0], [5, 5, 0, 5, 5, 5, 5, 0, 5, 0], [5, 5, 0, 5, 5, 0, 5, 5, 5, 5], [5, 5, 5, 0, 5, 5, 5, 5, 5, 5], [5, 0, 5, 5, 5, 0, 5, 0, 5, 5], [5, 5, 0, 5, 5, 5, 5, 5, 5, 5]]], "outputs": [[[5, 5, 5, 5, 3, 5, 5, 5, 3, 5], [1, 1, 5, 5, 5, 5, 5, 5, 5, 5], [1, 5, 5, 5, 5, 5, 1, 1, 5, 2], [5, 5, 3, 5, 5, 5, 5, 1, 5, 2], [5, 5, 5, 5, 2, 2, 5, 5, 5, 5], [2, 5, 3, 5, 5, 5, 5, 3, 5, 2], [2, 5, 5, 5, 2, 2, 5, 5, 5, 2], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 2], [3, 5, 5, 5, 5, 5, 5, 3, 5, 2]], [[5, 5, 5, 5, 5, 2, 2, 5, 5, 5], [2, 2, 5, 3, 5, 5, 5, 5, 5, 3], [5, 5, 5, 5, 5, 2, 5, 2, 2, 5], [5, 3, 5, 5, 5, 2, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 3, 5], [5, 5, 5, 5, 2, 5, 5, 5, 5, 5], [2, 2, 5, 5, 2, 5, 1, 1, 5, 3], [5, 5, 5, 5, 5, 5, 5, 1, 5, 5], [1, 5, 5, 5, 5, 5, 3, 5, 5, 3], [1, 1, 5, 5, 5, 5, 5, 5, 3, 5]], [[2, 2, 5, 5, 3, 5, 5, 5, 1, 5], [5, 5, 1, 1, 5, 5, 5, 5, 1, 5], [5, 2, 5, 1, 5, 3, 5, 5, 1, 5], [5, 2, 5, 5, 1, 5, 5, 5, 5, 5], [5, 5, 5, 1, 1, 5, 5, 2, 5, 2], [5, 5, 2, 5, 5, 5, 5, 2, 5, 2], [5, 5, 2, 5, 5, 3, 5, 5, 5, 5], [5, 5, 5, 3, 5, 5, 5, 5, 5, 5], [5, 3, 5, 5, 5, 3, 5, 3, 5, 5], [5, 5, 3, 5, 5, 5, 5, 5, 5, 5]]]}, "test_io": {"inputs": [[[0, 5, 5, 5, 5, 5, 0, 0, 5, 5], [5, 5, 5, 0, 5, 5, 0, 5, 0, 5], [5, 5, 0, 5, 5, 5, 5, 5, 0, 5], [5, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 5, 5, 5, 5, 5, 0, 5, 5, 5], [0, 5, 5, 0, 5, 5, 0, 5, 0, 0], [5, 5, 0, 5, 5, 5, 5, 5, 0, 5], [5, 5, 0, 5, 5, 5, 5, 5, 5, 0], [0, 0, 5, 5, 5, 5, 0, 5, 5, 5], [5, 5, 5, 5, 0, 5, 0, 0, 5, 0]]], "outputs": [[[3, 5, 5, 5, 5, 5, 1, 1, 5, 5], [5, 5, 5, 3, 5, 5, 1, 5, 2, 5], [5, 5, 1, 5, 5, 5, 5, 5, 2, 5], [5, 1, 1, 5, 5, 5, 5, 5, 5, 5], [2, 5, 5, 5, 5, 5, 2, 5, 5, 5], [2, 5, 5, 3, 5, 5, 2, 5, 1, 1], [5, 5, 2, 5, 5, 5, 5, 5, 1, 5], [5, 5, 2, 5, 5, 5, 5, 5, 5, 3], [2, 2, 5, 5, 5, 5, 1, 5, 5, 5], [5, 5, 5, 5, 3, 5, 1, 1, 5, 3]]]}, "solved": true, "generalizable": true, "anpl": "import numpy as np\nfrom typing import *\n(black, blue, red, green, yellow, grey, pink, orange, teal, maroon) = range(10)\n\ndef fill_single_black_area_blue(input_grid: np.ndarray, i: int, j: int) -> None:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to color the black area of the given point blue.                                                                   \n    \"\"\"\n    if input_grid[i][j] != yellow:\n        return\n    input_grid[i][j] = blue\n    if i > 0:\n        fill_single_black_area_blue(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        fill_single_black_area_blue(input_grid, i + 1, j)\n    if j > 0:\n        fill_single_black_area_blue(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        fill_single_black_area_blue(input_grid, i, j + 1)\n\ndef fill_single_black_area_red(input_grid: np.ndarray, i: int, j: int) -> None:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to color the black area of the given point blue.                                                                   \n    \"\"\"\n    if input_grid[i][j] != yellow:\n        return\n    input_grid[i][j] = red\n    if i > 0:\n        fill_single_black_area_red(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        fill_single_black_area_red(input_grid, i + 1, j)\n    if j > 0:\n        fill_single_black_area_red(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        fill_single_black_area_red(input_grid, i, j + 1)\n\ndef fill_single_black_area(input_grid: np.ndarray, i: int, j: int) -> None:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to color the black area of the given point blue.                                                                   \n    \"\"\"\n    if input_grid[i][j] != yellow:\n        return\n    input_grid[i][j] = green\n    if i > 0:\n        fill_single_black_area(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        fill_single_black_area(input_grid, i + 1, j)\n    if j > 0:\n        fill_single_black_area(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        fill_single_black_area(input_grid, i, j + 1)\n\ndef count_connected_black_points(input_grid: np.ndarray, i: int, j: int) -> int:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to count how many black points are connected to the given point.                                                   \n    It returns the count of connected black points.                                                                                                      \n    \"\"\"\n    if input_grid[i][j] != black:\n        return 0\n    count = 1\n    input_grid[i][j] = yellow\n    if i > 0:\n        count += count_connected_black_points(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        count += count_connected_black_points(input_grid, i + 1, j)\n    if j > 0:\n        count += count_connected_black_points(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        count += count_connected_black_points(input_grid, i, j + 1)\n    return count\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    for i in range(len(input_grid)):\n        for j in range(len(input_grid[0])):\n            count = count_connected_black_points(input_grid, i, j)\n            if count == 1:\n                fill_single_black_area(input_grid, i, j)\n            elif count == 2:\n                fill_single_black_area_red(input_grid, i, j)\n            elif count == 3:\n                fill_single_black_area_blue(input_grid, i, j)\n    return input_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef fill_single_black_area_blue(input_grid: np.ndarray, i: int, j: int) -> None:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to color the black area of the given point blue.                                                                   \n    \"\"\"\n    if input_grid[i][j] != yellow:\n        return\n    input_grid[i][j] = blue\n    if i > 0:\n        fill_single_black_area_blue(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        fill_single_black_area_blue(input_grid, i + 1, j)\n    if j > 0:\n        fill_single_black_area_blue(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        fill_single_black_area_blue(input_grid, i, j + 1)\n\ndef fill_single_black_area_red(input_grid: np.ndarray, i: int, j: int) -> None:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to color the black area of the given point blue.                                                                   \n    \"\"\"\n    if input_grid[i][j] != yellow:\n        return\n    input_grid[i][j] = red\n    if i > 0:\n        fill_single_black_area_red(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        fill_single_black_area_red(input_grid, i + 1, j)\n    if j > 0:\n        fill_single_black_area_red(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        fill_single_black_area_red(input_grid, i, j + 1)\n\ndef fill_single_black_area(input_grid: np.ndarray, i: int, j: int) -> None:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to color the black area of the given point blue.                                                                   \n    \"\"\"\n    if input_grid[i][j] != yellow:\n        return\n    input_grid[i][j] = green\n    if i > 0:\n        fill_single_black_area(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        fill_single_black_area(input_grid, i + 1, j)\n    if j > 0:\n        fill_single_black_area(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        fill_single_black_area(input_grid, i, j + 1)\n\ndef count_connected_black_points(input_grid: np.ndarray, i: int, j: int) -> int:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to count how many black points are connected to the given point.                                                   \n    It returns the count of connected black points.                                                                                                      \n    \"\"\"\n    if input_grid[i][j] != black:\n        return 0\n    count = 1\n    input_grid[i][j] = yellow\n    if i > 0:\n        count += count_connected_black_points(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        count += count_connected_black_points(input_grid, i + 1, j)\n    if j > 0:\n        count += count_connected_black_points(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        count += count_connected_black_points(input_grid, i, j + 1)\n    return count\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    for i in range(len(input_grid)):\n        for j in range(len(input_grid[0])):\n            count = count_connected_black_points(input_grid, i, j)\n            if count == 1:\n                fill_single_black_area(input_grid, i, j)\n            elif count == 2:\n                fill_single_black_area_red(input_grid, i, j)\n            elif count == 3:\n                fill_single_black_area_blue(input_grid, i, j)\n    return input_grid"}
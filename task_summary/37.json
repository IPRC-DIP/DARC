{"id": 37, "train_io": {"inputs": [[[0, 0, 0, 0, 2, 2, 0, 0, 1], [0, 1, 1, 0, 2, 2, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 2], [1, 0, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 2, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1]], [[1, 1, 0, 2, 0, 0, 0, 0, 2], [1, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 2, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 2, 2, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 1, 1, 0], [0, 1, 0, 2, 2, 0, 1, 1, 0]], [[2, 2, 0, 1, 1, 0, 0, 0, 0], [2, 2, 0, 1, 1, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 1, 1], [0, 2, 2, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 2, 2], [0, 1, 1, 0, 0, 1, 0, 2, 2]]], "outputs": [[[1, 1, 0, 0, 0]], [[1, 1, 1, 1, 0]], [[1, 1, 1, 1, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 2, 2, 0, 1], [1, 1, 0, 1, 0, 2, 2, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 2, 2, 0, 0, 1, 1, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 2, 2, 0], [2, 2, 0, 1, 1, 0, 2, 2, 0], [2, 2, 0, 1, 1, 0, 0, 0, 0]]], "outputs": [[[1, 1, 1, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    blue_grid_cnt = \"Traversing the input_grid, looking for the sub-grid with the shape (2,2) and the color blue in the input_gird, and returning the total number found\"(input_grid)\n    ans_grid = \"generate a 1*5 grid, paint the left blue_grid_cnt pixel blue;the other pixel black. return the modified new grid\"(blue_grid_cnt)\n    return ans_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef generate_modified_grid(blue_grid_cnt: int) -> np.ndarray:\n    \"\"\"\n    Generates a 1*5 grid, paints the left blue_grid_cnt pixel blue, and the other pixel black. Returns the modified new grid.\n    \"\"\"\n    modified_grid = np.zeros((1, 5))\n    modified_grid[0, :blue_grid_cnt] = blue\n    modified_grid[0, blue_grid_cnt:] = black\n    return modified_grid\n\ndef count_blue_subgrids(input_grid: np.ndarray) -> int:\n    \"\"\"\n    Traverses the input_grid, looking for the sub-grid with the shape (2,2) and the color blue in the input_gird, and returns the total number found.\n    \"\"\"\n    blue_subgrid_cnt = 0\n    for i in range(input_grid.shape[0] - 1):\n        for j in range(input_grid.shape[1] - 1):\n            if input_grid[i][j] == blue and input_grid[i][j + 1] == blue and (input_grid[i + 1][j] == blue) and (input_grid[i + 1][j + 1] == blue):\n                blue_subgrid_cnt += 1\n    return blue_subgrid_cnt\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    blue_grid_cnt = count_blue_subgrids(input_grid)\n    ans_grid = generate_modified_grid(blue_grid_cnt)\n    return ans_grid"}
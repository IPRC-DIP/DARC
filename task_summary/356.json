{"id": 356, "train_io": {"inputs": [[[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [1, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [1, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0]]], "outputs": [[[8, 1], [1, 8], [8, 1], [1, 8], [8, 1], [1, 8], [8, 1], [1, 8], [8, 1], [1, 8]], [[8, 1, 8], [1, 8, 8], [8, 1, 8], [8, 8, 1], [8, 1, 8], [1, 8, 8], [8, 1, 8], [8, 8, 1], [8, 1, 8], [1, 8, 8]], [[8, 8, 8, 1], [8, 8, 1, 8], [8, 1, 8, 8], [1, 8, 8, 8], [8, 1, 8, 8], [8, 8, 1, 8], [8, 8, 8, 1], [8, 8, 1, 8], [8, 1, 8, 8], [1, 8, 8, 8]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0]]], "outputs": [[[8, 1, 8, 8, 8], [1, 8, 8, 8, 8], [8, 1, 8, 8, 8], [8, 8, 1, 8, 8], [8, 8, 8, 1, 8], [8, 8, 8, 8, 1], [8, 8, 8, 1, 8], [8, 8, 1, 8, 8], [8, 1, 8, 8, 8], [1, 8, 8, 8, 8]]]}, "solved": true, "generalizable": true, "anpl": "import numpy as np\nfrom typing import *\n(black, blue, red, green, yellow, grey, pink, orange, teal, maroon) = range(10)\n\ndef copy_blue_pixel_left_up(input_grid: np.ndarray, i: int, j: int) -> Tuple[int, int]:\n    while i > 0 and j > 0:\n        if input_grid[i][j] == blue:\n            input_grid[i - 1][j - 1] = blue\n        j -= 1\n        i -= 1\n    return (i, j)\n\ndef copy_blue_pixel_right_up(input_grid: np.ndarray, i: int, j: int) -> Tuple[int, int]:\n    while i > 0 and j < input_grid.shape[1] - 1:\n        if input_grid[i][j] == blue:\n            input_grid[i - 1][j + 1] = blue\n        j += 1\n        i -= 1\n    return (i, j)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    flag = `Is blue pixel reach the top`(input_grid)\n    (i, j) = (input_grid.shape[0] - 1, 0)\n    while not flag:\n        (i, j) = copy_blue_pixel_right_up(input_grid, i, j)\n        (i, j) = copy_blue_pixel_left_up(input_grid, i, j)\n        flag = `Is blue pixel reach the top`(input_grid)\n    `color black points to teal`(input_grid)\n    return input_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_black_to_teal(input_grid: np.ndarray) -> None:\n    input_grid[input_grid == black] = teal\n\ndef copy_blue_pixel_left_up(input_grid: np.ndarray, i: int, j: int) -> Tuple[int, int]:\n    while i > 0 and j > 0:\n        if input_grid[i][j] == blue:\n            input_grid[i - 1][j - 1] = blue\n        j -= 1\n        i -= 1\n    return (i, j)\n\ndef copy_blue_pixel_right_up(input_grid: np.ndarray, i: int, j: int) -> Tuple[int, int]:\n    while i > 0 and j < input_grid.shape[1] - 1:\n        if input_grid[i][j] == blue:\n            input_grid[i - 1][j + 1] = blue\n        j += 1\n        i -= 1\n    return (i, j)\n\ndef is_blue_pixel_reached_top(input_grid: np.ndarray) -> bool:\n    return blue in input_grid[0]\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    flag = is_blue_pixel_reached_top(input_grid)\n    i, j = (input_grid.shape[0] - 1, 0)\n    while not flag:\n        i, j = copy_blue_pixel_right_up(input_grid, i, j)\n        i, j = copy_blue_pixel_left_up(input_grid, i, j)\n        flag = is_blue_pixel_reached_top(input_grid)\n    change_black_to_teal(input_grid)\n    return input_grid"}
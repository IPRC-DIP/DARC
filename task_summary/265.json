{"id": 265, "train_io": {"inputs": [[[0, 0, 0, 0, 0], [0, 2, 0, 0, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 2]], [[0, 0, 2, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 2, 0], [0, 0, 0, 0, 0]]], "outputs": [[[3, 0, 6, 0, 0], [0, 0, 0, 0, 0], [8, 0, 7, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 8, 0, 7, 0], [0, 0, 0, 0, 0]], [[0, 0, 3, 0, 6], [0, 0, 0, 0, 0], [0, 0, 8, 0, 7]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0], [0, 0, 0, 0, 2], [0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 3, 0], [0, 0, 0, 0, 0], [0, 0, 0, 8, 0]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    p = \"find the red pixel\"(input_grid)\n    color = \"if the upper left neighbor of p exist, turn it to green, if the upper right neighbor of p exist, turn it to pink, if the bottom left neighbor of p exist, turn it to teal, if the bottom right neighbor of p exist, turn it to orange, return the grid\"(p, input_grid)\n    out = \"turn red pixel into black.\"(color)\n    return out", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef turn_red_pixel_to_black(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given an input grid, this function finds the first red pixel and turns it into black. \n    Then, it colors the neighboring pixels of the red pixel with specific colors and returns the updated grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    p = find_red_pixel(input_grid)\n    input_grid[p[0]][p[1]] = black\n    color = color_neighbors(p, input_grid)\n    return color\n\ndef color_neighbors(p: Tuple[int, int], input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a pixel coordinate and an input grid, this function colors the neighboring pixels of the given pixel\n    with specific colors and returns the updated grid.\n    \n    Args:\n    p: A tuple containing the row and column indices of the pixel to be colored.\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    if p[0] > 0:\n        if p[1] > 0:\n            input_grid[p[0] - 1][p[1] - 1] = green\n        if p[1] < input_grid.shape[1] - 1:\n            input_grid[p[0] - 1][p[1] + 1] = pink\n    if p[0] < input_grid.shape[0] - 1:\n        if p[1] > 0:\n            input_grid[p[0] + 1][p[1] - 1] = teal\n        if p[1] < input_grid.shape[1] - 1:\n            input_grid[p[0] + 1][p[1] + 1] = orange\n    return input_grid\n\ndef find_red_pixel(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Given an input grid, this function returns the coordinates of the first red pixel found.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A tuple containing the row and column indices of the first red pixel found.\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                return (i, j)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    p = find_red_pixel(input_grid)\n    color = color_neighbors(p, input_grid)\n    out = turn_red_pixel_to_black(color)\n    return out"}
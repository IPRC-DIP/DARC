{"id": 146, "train_io": {"inputs": [[[3, 3, 0], [0, 3, 0], [3, 0, 3]], [[0, 3, 0, 0, 0, 3], [0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 3, 0], [0, 3, 0, 0, 0, 0]], [[3, 3, 0, 3], [3, 3, 0, 0], [3, 0, 0, 3], [0, 0, 3, 3]], [[3, 3, 0, 0, 0, 0], [0, 3, 0, 0, 3, 0], [3, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0], [0, 3, 3, 0, 0, 3]]], "outputs": [[[8, 8, 0], [0, 8, 0], [3, 0, 3]], [[0, 8, 0, 0, 0, 3], [0, 8, 8, 8, 0, 0], [0, 0, 0, 0, 3, 0], [0, 3, 0, 0, 0, 0]], [[8, 8, 0, 3], [8, 8, 0, 0], [8, 0, 0, 8], [0, 0, 8, 8]], [[8, 8, 0, 0, 0, 0], [0, 8, 0, 0, 3, 0], [3, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0], [0, 8, 8, 0, 0, 3]]]}, "test_io": {"inputs": [[[3, 0, 3, 0, 3], [3, 3, 3, 0, 0], [0, 0, 0, 0, 3], [0, 3, 3, 0, 0], [0, 3, 3, 0, 0]]], "outputs": [[[8, 0, 8, 0, 3], [8, 8, 8, 0, 0], [0, 0, 0, 0, 3], [0, 8, 8, 0, 0], [0, 8, 8, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you can see some green pixels in the grid,                                                                                                            \n    The output is the same size as the input.                                                                                                                           \n    To make the output, if a green pixel has another green pixel on top or down or left on right, color the pixel to teal.                                              \n    \"\"\"\n    output_grid = input_grid.copy()\n    for i in range(output_grid.shape[0]):\n        for j in range(output_grid.shape[1]):\n            if \"the pixel is green and has another green pixel on top or down or left on right\"(output_grid[i][j], i, j, input_grid):\n                output_grid = \"color the green pixel to teal\"(output_grid, i, j)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_green_pixel_to_teal(grid: np.ndarray, i: int, j: int) -> np.ndarray:\n    \"\"\"\n    Color the green pixel to teal.\n    \n    Args:\n    - grid (np.ndarray): the input grid\n    - i (int): the row index of the pixel\n    - j (int): the column index of the pixel\n    \n    Returns:\n    - np.ndarray: the updated grid with the green pixel colored to teal\n    \"\"\"\n    grid[i][j] = teal\n    return grid\n\ndef is_green_with_adjacent_green_pixel(pixel: int, i: int, j: int, grid: np.ndarray) -> bool:\n    \"\"\"\n    Check if a pixel is green and has another green pixel on top or down or left on right.\n    \n    Args:\n    - pixel (int): the value of the pixel to check\n    - i (int): the row index of the pixel\n    - j (int): the column index of the pixel\n    - grid (np.ndarray): the input grid\n    \n    Returns:\n    - bool: True if the pixel is green and has another green pixel on top or down or left on right, False otherwise\n    \"\"\"\n    if pixel == green:\n        if i > 0 and grid[i - 1][j] == green:\n            return True\n        if i < grid.shape[0] - 1 and grid[i + 1][j] == green:\n            return True\n        if j > 0 and grid[i][j - 1] == green:\n            return True\n        if j < grid.shape[1] - 1 and grid[i][j + 1] == green:\n            return True\n    return False\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you can see some green pixels in the grid,                                                                                                            \n    The output is the same size as the input.                                                                                                                           \n    To make the output, if a green pixel has another green pixel on top or down or left on right, color the pixel to teal.                                              \n    \"\"\"\n    output_grid = input_grid.copy()\n    for i in range(output_grid.shape[0]):\n        for j in range(output_grid.shape[1]):\n            if is_green_with_adjacent_green_pixel(output_grid[i][j], i, j, input_grid):\n                output_grid = color_green_pixel_to_teal(output_grid, i, j)\n    return output_grid"}
{"id": 300, "train_io": {"inputs": [[[0, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0], [1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8]], [[0, 0, 0, 1], [0, 0, 0, 0], [2, 2, 2, 0], [0, 0, 0, 0], [0, 3, 3, 0], [0, 0, 0, 0], [8, 8, 8, 8]], [[2, 2, 0], [0, 4, 0], [8, 8, 8]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 4, 4, 4, 4], [0, 0, 6, 6, 6, 6, 6], [0, 5, 5, 5, 5, 5, 5], [8, 8, 8, 8, 8, 8, 8]], [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 3, 3], [0, 2, 2, 2], [8, 8, 8, 8]], [[0, 0, 4], [0, 2, 2], [8, 8, 8]]]}, "test_io": {"inputs": [[[6, 6, 6, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 3, 3, 3, 3, 3, 3], [0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9], [0, 0, 0, 0, 0, 0, 7, 7], [0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 4, 4, 4, 4, 4], [0, 0, 3, 3, 3, 3, 3, 3], [0, 2, 2, 2, 2, 2, 2, 2], [8, 8, 8, 8, 8, 8, 8, 8]]]}, "solved": true, "generalizable": true, "anpl": null, "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef put_pixels_right_to_left_at_row(color: int, row: int, number: int, output_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Puts the given number of pixels of the given color from right to left at the given row in the output grid.\n\n    Args:\n    color: An integer representing the color of the pixels to be put.\n    row: An integer representing the row at which the pixels are to be put.\n    number: An integer representing the number of pixels to be put.\n    output_grid: A numpy array representing the output grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    for i in range(number):\n        output_grid[row][output_grid.shape[1] - 1 - i] = color\n    return output_grid\n\ndef count_non_black_pixels(input_grid: np.ndarray) -> List[int]:\n    \"\"\"\n    Counts the number of non-black pixels of each color in the input grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A list of integers representing the count of non-black pixels of each color.\n    \"\"\"\n    color_counts = [0] * 10\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black:\n                color_counts[input_grid[i][j]] += 1\n    sorted_color = sorted(range(len(color_counts)), key=lambda k: color_counts[k], reverse=True)\n    return sorted_color\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    sorted_color = count_non_black_pixels(input_grid)\n    output_grid = np.zeros_like(input_grid)\n    for i in range(len(sorted_color)):\n        color = sorted_color[i]\n        row = output_grid.shape[0] - 1 - i\n        number = output_grid.shape[1] - i\n        output_grid = put_pixels_right_to_left_at_row(color, row, number, output_grid)\n    return output_grid"}
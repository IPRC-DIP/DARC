{"id": 182, "train_io": {"inputs": [[[2, 1, 0, 0, 0, 0, 1, 3], [1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 8, 0, 0, 1, 0], [0, 1, 8, 8, 0, 8, 1, 0], [0, 1, 0, 0, 8, 0, 1, 0], [0, 1, 8, 0, 8, 8, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1], [4, 1, 0, 0, 0, 0, 1, 6]], [[9, 1, 0, 0, 1, 4], [1, 1, 1, 1, 1, 1], [0, 1, 8, 8, 1, 0], [0, 1, 8, 0, 1, 0], [1, 1, 1, 1, 1, 1], [2, 1, 0, 0, 1, 3]], [[6, 1, 0, 0, 0, 0, 1, 2], [1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 8, 0, 8, 1, 0], [0, 1, 8, 8, 8, 0, 1, 0], [0, 1, 8, 0, 8, 8, 1, 0], [0, 1, 8, 8, 8, 0, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1], [7, 1, 0, 0, 0, 0, 1, 4]]], "outputs": [[[0, 2, 0, 0], [2, 2, 0, 3], [0, 0, 6, 0], [4, 0, 6, 6]], [[9, 4], [2, 0]], [[0, 6, 0, 2], [6, 6, 2, 0], [7, 0, 4, 4], [7, 7, 4, 0]]]}, "test_io": {"inputs": [[[3, 1, 0, 0, 0, 0, 0, 0, 1, 4], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 8, 8, 0, 0, 0, 1, 0], [0, 1, 8, 8, 8, 0, 8, 0, 1, 0], [0, 1, 0, 0, 8, 0, 8, 0, 1, 0], [0, 1, 0, 8, 0, 8, 8, 0, 1, 0], [0, 1, 8, 8, 0, 8, 0, 8, 1, 0], [0, 1, 0, 8, 0, 0, 8, 0, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [7, 1, 0, 0, 0, 0, 0, 0, 1, 5]]], "outputs": [[[0, 3, 3, 0, 0, 0], [3, 3, 3, 0, 4, 0], [0, 0, 3, 0, 4, 0], [0, 7, 0, 5, 5, 0], [7, 7, 0, 5, 0, 5], [0, 7, 0, 0, 5, 0]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = \"devide the input with all blue rows and pixels, remain the center grid\"(input_grid)\n    output_grid = \"turn non-black pixels in upper left quarter of output_grid into the color of the upper left pixel of input grid\"(output_grid, input_grid)\n    output_grid = \"turn non-black pixels in upper right quarter into the color of the upper right pixel of input grid\"(output_grid, input_grid)\n    output_grid = \"turn non-black pixels in lower left quarter into the color of the lower left pixel of input grid\"(output_grid, input_grid)\n    output_grid = \"turn non-black pixels in lower right quarter into the color of the lower right pixel of input grid\"(output_grid, input_grid)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef turn_lower_right_quarter(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Turns non-black pixels in lower right quarter of output_grid into the color of the lower right pixel of input grid.\n\n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    lower_right_color = input_grid[-1, -1]\n    rows, cols = output_grid.shape\n    for i in range(rows // 2, rows):\n        for j in range(cols // 2, cols):\n            if output_grid[i, j] != black:\n                output_grid[i, j] = lower_right_color\n    return output_grid\n\ndef turn_lower_left_quarter(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Turns non-black pixels in lower left quarter of output_grid into the color of the lower left pixel of input grid.\n\n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    lower_left_color = input_grid[-1, 0]\n    rows, cols = output_grid.shape\n    for i in range(rows // 2, rows):\n        for j in range(cols // 2):\n            if output_grid[i, j] != black:\n                output_grid[i, j] = lower_left_color\n    return output_grid\n\ndef turn_upper_right_quarter(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Turns non-black pixels in upper right quarter of output_grid into the color of the upper right pixel of input grid.\n\n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    upper_right_color = input_grid[0, -1]\n    rows, cols = output_grid.shape\n    for i in range(rows // 2):\n        for j in range(cols // 2, cols):\n            if output_grid[i, j] != black:\n                output_grid[i, j] = upper_right_color\n    return output_grid\n\ndef turn_upper_left_quarter(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Turns non-black pixels in upper left quarter of output_grid into the color of the upper left pixel of input grid.\n\n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    upper_left_color = input_grid[0, 0]\n    rows, cols = output_grid.shape\n    for i in range(rows // 2):\n        for j in range(cols // 2):\n            if output_grid[i, j] != black:\n                output_grid[i, j] = upper_left_color\n    return output_grid\n\ndef divide_input(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Divides the input grid by all blue rows and pixels, and returns the center grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the center grid.\n    \"\"\"\n    blue_rows = np.where(np.all(input_grid == blue, axis=1))[0]\n    blue_cols = np.where(np.all(input_grid == blue, axis=0))[0]\n    center_grid = input_grid[blue_rows[0] + 1:blue_rows[-1], blue_cols[0] + 1:blue_cols[-1]]\n    return center_grid\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = divide_input(input_grid)\n    output_grid = turn_upper_left_quarter(output_grid, input_grid)\n    output_grid = turn_upper_right_quarter(output_grid, input_grid)\n    output_grid = turn_lower_left_quarter(output_grid, input_grid)\n    output_grid = turn_lower_right_quarter(output_grid, input_grid)\n    return output_grid"}
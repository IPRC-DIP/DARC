{"id": 56, "train_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[8, 8, 0, 8, 8, 0], [0, 8, 0, 0, 8, 0], [8, 8, 8, 8, 8, 8]], [[0, 2, 0, 0, 2, 0], [2, 2, 2, 2, 2, 2], [2, 2, 0, 2, 2, 0]], [[0, 1, 1, 0, 1, 1], [1, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 3, 0, 0, 3], [3, 3, 3, 3, 3, 3], [3, 0, 0, 3, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    non_black_pixels = \"get the non_black_pixels in the input_grid\"(input_grid)\n    smallest_rect = \"find the smallest_rect which contains all of these non_black_pixels in the input_grid\"(non_black_pixels, input_grid)\n    output_grid = np.concatenate([smallest_rect, smallest_rect], axis=1)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_smallest_rect(non_black_pixels: List[Tuple[int, int]], input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns the smallest rectangle which contains all of the non-black pixels in the input grid.\n    \n    Args:\n    non_black_pixels: A list of tuples representing the non-black pixels in the input grid.\n    Each tuple contains the row and column indices of a non-black pixel.\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array representing the smallest rectangle which contains all of the non-black pixels in the input grid.\n    \"\"\"\n    min_row = min([pixel[0] for pixel in non_black_pixels])\n    max_row = max([pixel[0] for pixel in non_black_pixels])\n    min_col = min([pixel[1] for pixel in non_black_pixels])\n    max_col = max([pixel[1] for pixel in non_black_pixels])\n    smallest_rect = input_grid[min_row:max_row + 1, min_col:max_col + 1]\n    return smallest_rect\n\ndef get_non_black_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Returns a list of non-black pixels in the input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of tuples representing the non-black pixels in the input grid.\n    Each tuple contains the row and column indices of a non-black pixel.\n    \"\"\"\n    non_black_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black:\n                non_black_pixels.append((i, j))\n    return non_black_pixels\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    non_black_pixels = get_non_black_pixels(input_grid)\n    smallest_rect = find_smallest_rect(non_black_pixels, input_grid)\n    output_grid = np.concatenate([smallest_rect, smallest_rect], axis=1)\n    return output_grid"}
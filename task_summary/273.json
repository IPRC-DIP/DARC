{"id": 273, "train_io": {"inputs": [[[0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0], [0, 5, 0, 0, 5, 0], [0, 5, 0, 0, 5, 0], [0, 5, 8, 8, 5, 0], [0, 5, 5, 5, 5, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 5, 0], [0, 5, 0, 0, 0, 0, 0, 5, 0], [0, 5, 0, 0, 0, 0, 0, 5, 0], [0, 5, 8, 8, 8, 8, 8, 5, 0], [0, 5, 8, 8, 8, 8, 8, 5, 0], [0, 5, 8, 8, 8, 8, 8, 5, 0], [0, 5, 5, 5, 5, 5, 5, 5, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 0, 0]], [[0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0], [0, 5, 8, 8, 5, 0], [0, 5, 8, 8, 5, 0], [0, 5, 5, 5, 5, 0]], [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0], [0, 5, 0, 0, 0, 5, 0], [0, 5, 8, 8, 8, 5, 0], [0, 5, 8, 8, 8, 5, 0], [0, 5, 5, 5, 5, 5, 0]]], "outputs": [[[8, 8, 8], [0, 0, 0], [0, 0, 0]], [[8, 8, 8], [0, 0, 8], [0, 0, 0]], [[8, 8, 8], [0, 0, 0], [0, 0, 0]], [[8, 8, 0], [0, 0, 0], [0, 0, 0]], [[8, 0, 0], [0, 0, 0], [0, 0, 0]], [[8, 8, 0], [0, 0, 0], [0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 8, 8, 8, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 0, 0]]], "outputs": [[[8, 0, 0], [0, 0, 0], [0, 0, 0]]]}, "solved": true, "generalizable": false, "anpl": "import numpy as np\nfrom typing import *\n(black, blue, red, green, yellow, grey, pink, orange, teal, maroon) = range(10)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see some grey pixels and teal pixels.\n    The output grid is 3x3\n    find the row of the topest grey pixel, and the row of the topeset teal pixel, and compute the abs dist between the two.\n    color the output grid with teal according to the abs dist,\n    the way is first color first row from left to right, if the pixels are not enough, then color next row from right to left, then left to right, then right to left, etc. \n    \"\"\"\n    row_topest_grey = `find the row indice of the topest pixel`(input_grid, grey)\n    row_topest_teal = `find the row indice of the topest pixel`(input_grid, teal)\n    dist = abs(row_topest_grey - row_topest_teal)\n    output_grid = `make an empty 3x3 output_grid`()\n    row = 0\n    col = 0\n    dict = 1\n    while dist > 0:\n        output_grid[row][col] = teal\n        col += dict\n        dist -= 1\n        if col == 2 or col == 0:\n            row += 1\n            dict = -dict\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef make_empty_grid() -> np.ndarray:\n    return np.zeros((3, 3), dtype=int)\n\ndef find_top_row(input_grid: np.ndarray, color: int) -> int:\n    for row in range(input_grid.shape[0]):\n        if color in input_grid[row]:\n            return row\n    return -1\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see some grey pixels and teal pixels.\n    The output grid is 3x3\n    find the row of the topest grey pixel, and the row of the topeset teal pixel, and compute the abs dist between the two.\n    color the output grid with teal according to the abs dist,\n    the way is first color first row from left to right, if the pixels are not enough, then color next row from right to left, then left to right, then right to left, etc. \n    \"\"\"\n    row_topest_grey = find_top_row(input_grid, grey)\n    row_topest_teal = find_top_row(input_grid, teal)\n    dist = abs(row_topest_grey - row_topest_teal)\n    output_grid = make_empty_grid()\n    row = 0\n    col = 0\n    dict = 1\n    while dist > 0:\n        output_grid[row][col] = teal\n        col += dict\n        dist -= 1\n        if col == 2 or col == 0:\n            row += 1\n            dict = -dict\n    return output_grid"}
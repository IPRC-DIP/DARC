{"id": 373, "train_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0, 0, 5, 0, 0], [0, 5, 0, 0, 5, 0, 0, 5, 0, 0], [0, 5, 0, 0, 5, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0, 0, 5, 0, 0], [0, 5, 0, 0, 5, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 5, 5, 5, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 5, 5, 5, 5, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 5, 5, 5, 5, 5, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 4, 0, 0, 0, 0, 0], [0, 1, 0, 0, 4, 0, 0, 0, 0, 0], [0, 1, 0, 0, 4, 0, 0, 2, 0, 0], [0, 1, 0, 0, 4, 0, 0, 2, 0, 0], [0, 1, 0, 0, 4, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 4, 0, 0, 1, 0, 0, 0, 0, 0], [0, 4, 0, 0, 1, 0, 0, 0, 0, 0], [0, 4, 0, 0, 1, 0, 0, 2, 0, 0], [0, 4, 0, 0, 1, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 2, 2, 2, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 2, 2, 2, 2, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 4, 4, 4, 4, 4, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "solved": true, "generalizable": false, "anpl": "import numpy as np\nfrom typing import *\n(black, blue, red, green, yellow, grey, pink, orange, teal, maroon) = range(10)\n\ndef find_mid_length_grey_line(input_grid: np.ndarray) -> Tuple[int, int]:\n    longest_length = 1 + max(`find longest grey line`(input_grid)[1][0] - `find longest grey line`(input_grid)[0][0], `find longest grey line`(input_grid)[1][1] - `find longest grey line`(input_grid)[0][1])\n    shortest_length = 1 + max(find_shortest_grey_line(input_grid)[1][0] - find_shortest_grey_line(input_grid)[0][0], find_shortest_grey_line(input_grid)[1][1] - find_shortest_grey_line(input_grid)[0][1])\n    start_coord = (0, 0)\n    end_coord = (0, 0)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if i > start_coord[0] and i < end_coord[0]:\n                continue\n            if j > start_coord[1] and j < end_coord[1]:\n                continue\n            if input_grid[i - 1][j] == grey and i > 0 or (input_grid[i][j - 1] == grey and j > 0):\n                continue\n            if input_grid[i][j] == grey:\n                length = 1\n                for k in range(j + 1, input_grid.shape[1]):\n                    if input_grid[i][k] == grey:\n                        length += 1\n                    else:\n                        break\n                if length > shortest_length and length < longest_length:\n                    start_coord = (i, j)\n                    end_coord = (i, j + length - 1)\n                length = 1\n                for k in range(i + 1, input_grid.shape[0]):\n                    if input_grid[k][j] == grey:\n                        length += 1\n                    else:\n                        break\n                if length > shortest_length and length < longest_length:\n                    start_coord = (i, j)\n                    end_coord = (i + length - 1, j)\n    return (start_coord, end_coord)\n\ndef find_shortest_grey_line(input_grid: np.ndarray) -> Tuple[int, int]:\n    min_length = float('inf')\n    start_coord = (0, 0)\n    end_coord = (0, 0)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if i > start_coord[0] and i < end_coord[0]:\n                continue\n            if j > start_coord[1] and j < end_coord[1]:\n                continue\n            if input_grid[i - 1][j] == grey and i > 0 or (input_grid[i][j - 1] == grey and j > 0):\n                continue\n            if input_grid[i][j] == grey:\n                length = 1\n                for k in range(j + 1, input_grid.shape[1]):\n                    if input_grid[i][k] == grey:\n                        length += 1\n                    else:\n                        break\n                if length < min_length and length > 1:\n                    min_length = length\n                    start_coord = (i, j)\n                    end_coord = (i, j + length - 1)\n                length = 1\n                for k in range(i + 1, input_grid.shape[0]):\n                    if input_grid[k][j] == grey:\n                        length += 1\n                    else:\n                        break\n                if length < min_length and length > 1:\n                    min_length = length\n                    start_coord = (i, j)\n                    end_coord = (i + length - 1, j)\n    return (start_coord, end_coord)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    color the lines based on their length: longest is blue, medium is yellow, and smallest is red.\n    \"\"\"\n    output_grid = input_grid.copy()\n    longest_line = `find longest grey line`(input_grid)\n    shortest_line = find_shortest_grey_line(input_grid)\n    mid_line = find_mid_length_grey_line(input_grid)\n    output_grid = `color select line`(output_grid, longest_line, blue)\n    output_grid = `color select line`(output_grid, shortest_line, red)\n    output_grid = `color select line`(output_grid, mid_line, yellow)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_select_line(grid: np.ndarray, line_coords: Tuple[int, int], color: int) -> np.ndarray:\n    \"\"\"\n    Colors the given line in the grid with the specified color.\n    \"\"\"\n    start_coord, end_coord = line_coords\n    if start_coord[0] == end_coord[0]:\n        for j in range(start_coord[1], end_coord[1] + 1):\n            grid[start_coord[0]][j] = color\n    else:\n        for i in range(start_coord[0], end_coord[0] + 1):\n            grid[i][start_coord[1]] = color\n    return grid\n\ndef find_mid_length_grey_line(input_grid: np.ndarray) -> Tuple[int, int]:\n    longest_length = 1 + max(find_longest_grey_line(input_grid)[1][0] - find_longest_grey_line(input_grid)[0][0], find_longest_grey_line(input_grid)[1][1] - find_longest_grey_line(input_grid)[0][1])\n    shortest_length = 1 + max(find_shortest_grey_line(input_grid)[1][0] - find_shortest_grey_line(input_grid)[0][0], find_shortest_grey_line(input_grid)[1][1] - find_shortest_grey_line(input_grid)[0][1])\n    start_coord = (0, 0)\n    end_coord = (0, 0)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if i > start_coord[0] and i < end_coord[0]:\n                continue\n            if j > start_coord[1] and j < end_coord[1]:\n                continue\n            if input_grid[i - 1][j] == grey and i > 0 or (input_grid[i][j - 1] == grey and j > 0):\n                continue\n            if input_grid[i][j] == grey:\n                length = 1\n                for k in range(j + 1, input_grid.shape[1]):\n                    if input_grid[i][k] == grey:\n                        length += 1\n                    else:\n                        break\n                if length > shortest_length and length < longest_length:\n                    start_coord = (i, j)\n                    end_coord = (i, j + length - 1)\n                length = 1\n                for k in range(i + 1, input_grid.shape[0]):\n                    if input_grid[k][j] == grey:\n                        length += 1\n                    else:\n                        break\n                if length > shortest_length and length < longest_length:\n                    start_coord = (i, j)\n                    end_coord = (i + length - 1, j)\n    return (start_coord, end_coord)\n\ndef find_shortest_grey_line(input_grid: np.ndarray) -> Tuple[int, int]:\n    min_length = float('inf')\n    start_coord = (0, 0)\n    end_coord = (0, 0)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if i > start_coord[0] and i < end_coord[0]:\n                continue\n            if j > start_coord[1] and j < end_coord[1]:\n                continue\n            if input_grid[i - 1][j] == grey and i > 0 or (input_grid[i][j - 1] == grey and j > 0):\n                continue\n            if input_grid[i][j] == grey:\n                length = 1\n                for k in range(j + 1, input_grid.shape[1]):\n                    if input_grid[i][k] == grey:\n                        length += 1\n                    else:\n                        break\n                if length < min_length and length > 1:\n                    min_length = length\n                    start_coord = (i, j)\n                    end_coord = (i, j + length - 1)\n                length = 1\n                for k in range(i + 1, input_grid.shape[0]):\n                    if input_grid[k][j] == grey:\n                        length += 1\n                    else:\n                        break\n                if length < min_length and length > 1:\n                    min_length = length\n                    start_coord = (i, j)\n                    end_coord = (i + length - 1, j)\n    return (start_coord, end_coord)\n\ndef find_longest_grey_line(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Finds the longest grey line in the input grid and returns its starting and ending coordinates.\n    \"\"\"\n    max_length = 0\n    start_coord = (0, 0)\n    end_coord = (0, 0)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == grey:\n                length = 1\n                for k in range(j + 1, input_grid.shape[1]):\n                    if input_grid[i][k] == grey:\n                        length += 1\n                    else:\n                        break\n                if length > max_length:\n                    max_length = length\n                    start_coord = (i, j)\n                    end_coord = (i, j + length - 1)\n                length = 1\n                for k in range(i + 1, input_grid.shape[0]):\n                    if input_grid[k][j] == grey:\n                        length += 1\n                    else:\n                        break\n                if length > max_length:\n                    max_length = length\n                    start_coord = (i, j)\n                    end_coord = (i + length - 1, j)\n    return (start_coord, end_coord)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    color the lines based on their length: longest is blue, medium is yellow, and smallest is red.\n    \"\"\"\n    output_grid = input_grid.copy()\n    longest_line = find_longest_grey_line(input_grid)\n    shortest_line = find_shortest_grey_line(input_grid)\n    mid_line = find_mid_length_grey_line(input_grid)\n    output_grid = color_select_line(output_grid, longest_line, blue)\n    output_grid = color_select_line(output_grid, shortest_line, red)\n    output_grid = color_select_line(output_grid, mid_line, yellow)\n    return output_grid"}
{"id": 29, "train_io": {"inputs": [[[0, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 4, 4, 0, 1, 1, 0], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [0, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 1, 0, 2, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 4, 4, 0, 1, 1, 0], [0, 2, 2, 0, 4, 4, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 1, 1, 1, 4, 4, 4], [0, 2, 2, 2, 1, 1, 1, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 2, 0, 0, 4, 0, 0, 0], [0, 1, 0, 2, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 1, 1, 0, 0, 0, 0, 2, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 4, 4, 0, 0, 2, 2], [0, 1, 1, 0, 4, 4, 0, 0, 2, 2], [1, 0, 0, 4, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    (red_x1, red_x2, blue_x1, blue_x2, yellow_x1, yellow_x2) = \"Traverse the matrix from top to bottom and find the first and last row numbers where the red block appears (denoted as red_x1 and red_x2), the first and last row numbers where the blue block appears (denoted as blue_x1 and blue_x2), and the first and last row numbers where the yellow block appears (denoted as yellow_x1 and yellow_x2).\"(input_grid)\n    (red_y1, red_y2, blue_y1, blue_y2, yellow_y1, yellow_y2) = \"Traverse the matrix from left to right and find the first and last column numbers where the red block appears (denoted as red_y1 and red_y2), the first and last column numbers where the blue block appears (denoted as blue_y1 and blue_y2), and the first and last column numbers where the yellow block appears (denoted as yellow_y1 and yellow_y2).\"(input_grid)\n    (red_grid, blue_grid, yellow_grid) = \"In the input_grid, extract the image located in the rectangle with the upper-left corner at (red_x1,red_y1) and the lower-right corner at (red_x2,red_y2) (denoted as red_grid), the image located in the rectangle with the upper-left corner at (blue_x1,blue_y1) and the lower-right corner at (blue_x2,blue_y2) (denoted as blue_grid), and the image located in the rectangle with the upper-left corner at (yellow_x1,yellow_y1) and the lower-right corner at (yellow_x2,yellow_y2) (denoted as yellow_grid).\"(input_grid, red_x1, red_x2, red_y1, red_y2, blue_x1, blue_x2, blue_y1, blue_y2, yellow_x1, yellow_x2, yellow_y1, yellow_y2)\n    output_grid = \"Create a new image matrix of the same size as the original image, filled with black pixels (denoted as output_grid).\"(input_grid)\n    output_grid = \"Overlay blue_grid onto output_grid starting from the location (blue_x1,blue_y1), overlay red_grid onto output_grid starting from the location (blue_x1,red_y1), and overlay yellow_grid onto output_grid starting from the location (blue_x1,yellow_y1).\"(output_grid, red_grid, blue_grid, yellow_grid, blue_x1, blue_y1, red_y1, yellow_y1)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef overlay_grids(output_grid: np.ndarray, red_grid: np.ndarray, blue_grid: np.ndarray, yellow_grid: np.ndarray, blue_x1: int, blue_y1: int, red_y1: int, yellow_y1: int) -> np.ndarray:\n    output_grid[blue_x1:blue_x1 + blue_grid.shape[0], blue_y1:blue_y1 + blue_grid.shape[1]] = blue_grid\n    output_grid[blue_x1:red_grid.shape[0] + blue_x1, red_y1:red_grid.shape[1] + red_y1] = red_grid\n    output_grid[blue_x1:yellow_grid.shape[0] + blue_x1, yellow_y1:yellow_grid.shape[1] + yellow_y1] = yellow_grid\n    return output_grid\n\ndef create_black_image(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n    output_grid.fill(black)\n    return output_grid\n\ndef extract_images(input_grid: np.ndarray, red_x1: int, red_x2: int, red_y1: int, red_y2: int, blue_x1: int, blue_x2: int, blue_y1: int, blue_y2: int, yellow_x1: int, yellow_x2: int, yellow_y1: int, yellow_y2: int) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    red_grid = input_grid[red_x1:red_x2 + 1, red_y1:red_y2 + 1]\n    blue_grid = input_grid[blue_x1:blue_x2 + 1, blue_y1:blue_y2 + 1]\n    yellow_grid = input_grid[yellow_x1:yellow_x2 + 1, yellow_y1:yellow_y2 + 1]\n    return (red_grid, blue_grid, yellow_grid)\n\ndef find_block_columns(input_grid: np.ndarray) -> Tuple[int, int, int, int, int, int]:\n    red_y1, red_y2, blue_y1, blue_y2, yellow_y1, yellow_y2 = (-1, -1, -1, -1, -1, -1)\n    for j in range(input_grid.shape[1]):\n        for i in range(input_grid.shape[0]):\n            if input_grid[i][j] == red:\n                if red_y1 == -1:\n                    red_y1 = j\n                red_y2 = j\n            elif input_grid[i][j] == blue:\n                if blue_y1 == -1:\n                    blue_y1 = j\n                blue_y2 = j\n            elif input_grid[i][j] == yellow:\n                if yellow_y1 == -1:\n                    yellow_y1 = j\n                yellow_y2 = j\n    return (red_y1, red_y2, blue_y1, blue_y2, yellow_y1, yellow_y2)\n\ndef find_block_rows(input_grid: np.ndarray) -> Tuple[int, int, int, int, int, int]:\n    red_x1, red_x2, blue_x1, blue_x2, yellow_x1, yellow_x2 = (-1, -1, -1, -1, -1, -1)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                if red_x1 == -1:\n                    red_x1 = i\n                red_x2 = i\n            elif input_grid[i][j] == blue:\n                if blue_x1 == -1:\n                    blue_x1 = i\n                blue_x2 = i\n            elif input_grid[i][j] == yellow:\n                if yellow_x1 == -1:\n                    yellow_x1 = i\n                yellow_x2 = i\n    return (red_x1, red_x2, blue_x1, blue_x2, yellow_x1, yellow_x2)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    red_x1, red_x2, blue_x1, blue_x2, yellow_x1, yellow_x2 = find_block_rows(input_grid)\n    red_y1, red_y2, blue_y1, blue_y2, yellow_y1, yellow_y2 = find_block_columns(input_grid)\n    red_grid, blue_grid, yellow_grid = extract_images(input_grid, red_x1, red_x2, red_y1, red_y2, blue_x1, blue_x2, blue_y1, blue_y2, yellow_x1, yellow_x2, yellow_y1, yellow_y2)\n    output_grid = create_black_image(input_grid)\n    output_grid = overlay_grids(output_grid, red_grid, blue_grid, yellow_grid, blue_x1, blue_y1, red_y1, yellow_y1)\n    return output_grid"}
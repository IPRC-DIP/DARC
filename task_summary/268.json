{"id": 268, "train_io": {"inputs": [[[2, 0, 0], [0, 0, 7], [0, 0, 0]], [[0, 4, 0], [0, 0, 8], [6, 0, 0]], [[0, 6, 9], [3, 0, 2], [0, 7, 0]]], "outputs": [[[2, 2, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7], [0, 0, 0, 0, 7, 7], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], [[0, 0, 0, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 0, 0, 0, 8, 8, 8], [6, 6, 6, 0, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 9, 9, 9, 9, 9], [0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 9, 9, 9, 9, 9], [0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 9, 9, 9, 9, 9], [0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 9, 9, 9, 9, 9], [0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 9, 9, 9, 9, 9], [3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0]]]}, "test_io": {"inputs": [[[1, 0, 0], [0, 9, 6], [8, 0, 0]]], "outputs": [[[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 6, 6, 6, 6], [0, 0, 0, 0, 9, 9, 9, 9, 6, 6, 6, 6], [0, 0, 0, 0, 9, 9, 9, 9, 6, 6, 6, 6], [0, 0, 0, 0, 9, 9, 9, 9, 6, 6, 6, 6], [8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see...a 3x3 with any number of colors                                                                                                      \n    The output grid size...it get large enough to contain each color in more blocks                                                                                     \n    To make the output, you have to...zoom out and give each block its on space                                                                                         \n    \"\"\"\n    number = \"count the number of the colors except black\"(input_grid)\n    output_grid = np.zeros((input_grid.shape[0] * number, input_grid.shape[1] * number), dtype=int)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            output_grid[i * number:(i + 1) * number, j * number:(j + 1) * number] = input_grid[i][j]\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef count_colors_except_black(input_grid: np.ndarray) -> int:\n    \"\"\"\n    This function takes in a 3x3 grid with any number of colors and counts the number of colors except black.\n    \n    Args:\n    input_grid: A numpy array of shape (3,3) containing integers representing colors.\n    \n    Returns:\n    An integer representing the count of colors except black in the input grid.\n    \"\"\"\n    unique_colors = np.unique(input_grid)\n    count = len(unique_colors) - 1 if 0 in unique_colors else len(unique_colors)\n    return count\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see...a 3x3 with any number of colors                                                                                                      \n    The output grid size...it get large enough to contain each color in more blocks                                                                                     \n    To make the output, you have to...zoom out and give each block its on space                                                                                         \n    \"\"\"\n    number = count_colors_except_black(input_grid)\n    output_grid = np.zeros((input_grid.shape[0] * number, input_grid.shape[1] * number), dtype=int)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            output_grid[i * number:(i + 1) * number, j * number:(j + 1) * number] = input_grid[i][j]\n    return output_grid"}
{"id": 326, "train_io": {"inputs": [[[6, 1, 0], [3, 0, 0], [0, 0, 0]], [[0, 4, 0], [0, 8, 0], [2, 0, 0]], [[0, 0, 6], [1, 3, 0], [0, 0, 0]]], "outputs": [[[6, 1, 0, 0, 0, 0], [3, 6, 1, 0, 0, 0], [0, 3, 6, 1, 0, 0], [0, 0, 3, 6, 1, 0], [0, 0, 0, 3, 6, 1], [0, 0, 0, 0, 3, 6]], [[0, 4, 0, 0, 0, 0], [0, 8, 4, 0, 0, 0], [2, 0, 8, 4, 0, 0], [0, 2, 0, 8, 4, 0], [0, 0, 2, 0, 8, 4], [0, 0, 0, 2, 0, 8]], [[0, 0, 6, 0, 0, 0], [1, 3, 0, 6, 0, 0], [0, 1, 3, 0, 6, 0], [0, 0, 1, 3, 0, 6], [0, 0, 0, 1, 3, 0], [0, 0, 0, 0, 1, 3]]]}, "test_io": {"inputs": [[[0, 0, 3], [0, 0, 0], [0, 4, 9]]], "outputs": [[[0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0], [0, 4, 9, 0, 3, 0], [0, 0, 4, 9, 0, 3], [0, 0, 0, 4, 9, 0], [0, 0, 0, 0, 4, 9]]]}, "solved": true, "generalizable": false, "anpl": "import numpy as np\nfrom typing import *\n(black, blue, red, green, yellow, grey, pink, orange, teal, maroon) = range(10)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    color_pixels = `Traverse the input_grid. If a non-black pixel is encountered, record its color and coordinates.`(input_grid)\n    output_grid = `Create a completely black image matrix with dimensions of 6x6.`()\n    output_grid = `Traverse the pixels recorded in step1 and perform the following: Assuming the current pixel coordinate is (i,j) and the color is c, color all pixels in the bottom-right 45-degree direction from the current pixel (coordinates (i+1,j+1), (i+2,j+2), (i+3,j+3),...) with the color c.`(output_grid, color_pixels)\n    output_grid = `Cover the 3x3 region on output_grid with input_grid starting at top left corner (0,0) and ending at bottom right corner (2,2).`(output_grid, input_grid)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef cover_3x3_region(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes an output grid and an input grid and covers the 3x3 region on the output grid with the input grid\n    starting at the top left corner (0,0) and ending at the bottom right corner (2,2).\n    \n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array representing the output grid with the 3x3 region covered with the input grid.\n    \"\"\"\n    output_grid[:3, :3] = input_grid[:3, :3]\n    return output_grid\n\ndef color_bottom_right_pixels(input_grid: np.ndarray, color_pixels: List[Tuple[int, int, int]]) -> np.ndarray:\n    \"\"\"\n    This function takes an input grid and a list of tuples containing the color and coordinates of non-black pixels.\n    It colors all pixels in the bottom-right 45-degree direction from the current pixel with the same color.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    color_pixels: A list of tuples containing the color and coordinates of non-black pixels.\n    \n    Returns:\n    A numpy array representing the output grid with colored pixels.\n    \"\"\"\n    for color, i, j in color_pixels:\n        k = 1\n        while i + k < input_grid.shape[0] and j + k < input_grid.shape[1]:\n            if input_grid[i + k][j + k] == black:\n                input_grid[i + k][j + k] = color\n            k += 1\n    return input_grid\n\ndef create_black_image() -> np.ndarray:\n    \"\"\"\n    This function creates a completely black image matrix with dimensions of 6x6.\n    \n    Returns:\n    A numpy array representing the black image matrix.\n    \"\"\"\n    return np.zeros((6, 6), dtype=int)\n\ndef get_color_pixels(input_grid: np.ndarray) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    This function takes an input grid and returns a list of tuples containing the color and coordinates of non-black pixels.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of tuples containing the color and coordinates of non-black pixels.\n    \"\"\"\n    color_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black:\n                color_pixels.append((input_grid[i][j], i, j))\n    return color_pixels\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    color_pixels = get_color_pixels(input_grid)\n    output_grid = create_black_image()\n    output_grid = color_bottom_right_pixels(output_grid, color_pixels)\n    output_grid = cover_3x3_region(output_grid, input_grid)\n    return output_grid"}
{"id": 385, "train_io": {"inputs": [[[7, 7, 0, 1, 5, 0, 0], [7, 0, 0, 1, 5, 0, 0], [0, 0, 0, 1, 5, 0, 5], [0, 0, 0, 1, 5, 5, 0]], [[7, 7, 0, 1, 5, 0, 0], [0, 0, 0, 1, 0, 0, 0], [7, 7, 0, 1, 5, 0, 0], [0, 7, 7, 1, 5, 5, 0]], [[0, 7, 7, 1, 5, 0, 0], [0, 0, 7, 1, 0, 5, 5], [0, 7, 0, 1, 5, 5, 0], [0, 0, 7, 1, 0, 0, 0]], [[7, 0, 7, 1, 5, 5, 0], [7, 7, 0, 1, 5, 5, 5], [0, 7, 0, 1, 0, 0, 0], [0, 0, 0, 1, 5, 0, 5]], [[7, 0, 0, 1, 0, 5, 0], [0, 0, 7, 1, 5, 0, 0], [0, 0, 0, 1, 5, 5, 5], [7, 7, 7, 1, 5, 5, 5]]], "outputs": [[[0, 0, 3], [0, 3, 3], [0, 3, 0], [0, 0, 3]], [[0, 0, 3], [3, 3, 3], [0, 0, 3], [0, 0, 0]], [[0, 0, 0], [3, 0, 0], [0, 0, 3], [3, 3, 0]], [[0, 0, 0], [0, 0, 0], [3, 0, 3], [0, 3, 0]], [[0, 0, 3], [0, 3, 0], [0, 0, 0], [0, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 1, 0, 5, 0], [7, 7, 7, 1, 5, 5, 0], [0, 0, 0, 1, 5, 0, 0], [7, 0, 0, 1, 5, 5, 5]]], "outputs": [[[3, 0, 3], [0, 0, 0], [0, 3, 3], [0, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": "import numpy as np\nfrom typing import *\n(black, blue, red, green, yellow, grey, pink, orange, teal, maroon) = range(10)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    (left, right) = `split input grid to two 4*3 grid by blue`(input_grid)\n    output = `create 4*3 black array`()\n    `check every loaction of output to green if left and right in same loaction both are black`(left, right, output)\n    return output", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef mark_common_black(left: np.ndarray, right: np.ndarray, output: np.ndarray) -> None:\n    \"\"\"\n    Marks every location of output to green if left and right in the same location both are black.\n\n    Args:\n    left (np.ndarray): The left half of the input grid.\n    right (np.ndarray): The right half of the input grid.\n    output (np.ndarray): The output grid.\n    \"\"\"\n    for i in range(output.shape[0]):\n        for j in range(output.shape[1]):\n            if left[i][j] == black and right[i][j] == black:\n                output[i][j] = green\n\ndef create_black_array() -> np.ndarray:\n    return np.full((4, 3), black)\n\ndef split_grid(input_grid: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Splits the input grid into two 4x3 grids based on the blue color.\n\n    Args:\n    input_grid (np.ndarray): The input grid.\n\n    Returns:\n    Tuple[np.ndarray, np.ndarray]: The left and right 4x3 grids.\n    \"\"\"\n    blue_indices = np.where(input_grid == blue)\n    blue_columns = np.unique(blue_indices[1])\n    blue_column_index = blue_columns[0]\n    left = input_grid[:, :blue_column_index]\n    right = input_grid[:, blue_column_index + 1:]\n    return (left, right)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    left, right = split_grid(input_grid)\n    output = create_black_array()\n    mark_common_black(left, right, output)\n    return output"}
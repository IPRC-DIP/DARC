{"id": 352, "train_io": {"inputs": [[[3, 0, 0], [0, 0, 0], [0, 0, 4]], [[0, 0, 0], [3, 0, 4], [0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 3, 0, 0, 4], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 3], [0, 0, 0], [4, 0, 0]]], "outputs": [[[0, 0, 0], [0, 3, 0], [0, 0, 4]], [[0, 0, 0], [0, 3, 4], [0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 3, 0, 4], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0], [0, 3, 0], [4, 0, 0]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[4, 0, 0], [0, 0, 0], [0, 0, 3]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[4, 0, 0], [0, 3, 0], [0, 0, 0]]]}, "solved": true, "generalizable": true, "anpl": "import numpy as np\nfrom typing import *\n(black, blue, red, green, yellow, grey, pink, orange, teal, maroon) = range(10)\n\ndef move_green_to_yellow(output_grid: np.ndarray, pos_green: Tuple[int, int], pos_yellow: Tuple[int, int]) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    This function takes an input grid, the position of the green pixel, and the position of the yellow pixel.                                                           \n    It moves the green pixel one block closer to the yellow pixel, no matter if it is horizontal, diagonal, or vertical.                                                \n    Move green to yellow, not yellow to green!                                                                                                                          \n                                                                                                                                                                        \n    Args:                                                                                                                                                               \n    output_grid: A numpy array representing the input grid.                                                                                                              \n    pos_green: A tuple (row, column) representing the position of the green pixel.                                                                                      \n    pos_yellow: A tuple (row, column) representing the position of the yellow pixel.                                                                                    \n                                                                                                                                                                        \n    Returns:                                                                                                                                                            \n    A numpy array representing the output grid with the green pixel moved one block closer to the yellow pixel.                                                         \n    \"\"\"\n    row_diff = pos_green[0] - pos_yellow[0]\n    col_diff = pos_green[1] - pos_yellow[1]\n    if row_diff == 0:\n        if col_diff > 0:\n            output_grid[pos_green[0], pos_green[1] - 1] = green\n        else:\n            output_grid[pos_green[0], pos_green[1] + 1] = green\n    elif col_diff == 0:\n        if row_diff > 0:\n            output_grid[pos_green[0] - 1, pos_green[1]] = green\n        else:\n            output_grid[pos_green[0] + 1, pos_green[1]] = green\n    elif row_diff > 0:\n        if col_diff > 0:\n            output_grid[pos_green[0] - 1, pos_green[1] - 1] = green\n        else:\n            output_grid[pos_green[0] - 1, pos_green[1] + 1] = green\n    elif col_diff > 0:\n        output_grid[pos_green[0] + 1, pos_green[1] - 1] = green\n    else:\n        output_grid[pos_green[0] + 1, pos_green[1] + 1] = green\n    output_grid[pos_green] = black\n    return output_grid\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you can see a green pixel and a yellow pixel.\n    The output is the same size as the input.\n    To make the output, you have to...move the green square one block closer to the yellow square, no matter if it is horizontal, diagonal, or vertical.                                      \n    \"\"\"\n    output_grid = input_grid.copy()\n    pos_green = `get position of green pixel`(input_grid)\n    pos_yellow = `get position of yellow pixel`(input_grid)\n    output_grid = move_green_to_yellow(output_grid, pos_green, pos_yellow)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef move_green_to_yellow(output_grid: np.ndarray, pos_green: Tuple[int, int], pos_yellow: Tuple[int, int]) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    This function takes an input grid, the position of the green pixel, and the position of the yellow pixel.                                                           \n    It moves the green pixel one block closer to the yellow pixel, no matter if it is horizontal, diagonal, or vertical.                                                \n    Move green to yellow, not yellow to green!                                                                                                                          \n                                                                                                                                                                        \n    Args:                                                                                                                                                               \n    output_grid: A numpy array representing the input grid.                                                                                                              \n    pos_green: A tuple (row, column) representing the position of the green pixel.                                                                                      \n    pos_yellow: A tuple (row, column) representing the position of the yellow pixel.                                                                                    \n                                                                                                                                                                        \n    Returns:                                                                                                                                                            \n    A numpy array representing the output grid with the green pixel moved one block closer to the yellow pixel.                                                         \n    \"\"\"\n    row_diff = pos_green[0] - pos_yellow[0]\n    col_diff = pos_green[1] - pos_yellow[1]\n    if row_diff == 0:\n        if col_diff > 0:\n            output_grid[pos_green[0], pos_green[1] - 1] = green\n        else:\n            output_grid[pos_green[0], pos_green[1] + 1] = green\n    elif col_diff == 0:\n        if row_diff > 0:\n            output_grid[pos_green[0] - 1, pos_green[1]] = green\n        else:\n            output_grid[pos_green[0] + 1, pos_green[1]] = green\n    elif row_diff > 0:\n        if col_diff > 0:\n            output_grid[pos_green[0] - 1, pos_green[1] - 1] = green\n        else:\n            output_grid[pos_green[0] - 1, pos_green[1] + 1] = green\n    elif col_diff > 0:\n        output_grid[pos_green[0] + 1, pos_green[1] - 1] = green\n    else:\n        output_grid[pos_green[0] + 1, pos_green[1] + 1] = green\n    output_grid[pos_green] = black\n    return output_grid\n\ndef get_yellow_position(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    This function takes an input grid and returns the position of the yellow pixel in the form of a tuple (row, column).\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A tuple (row, column) representing the position of the yellow pixel.\n    \"\"\"\n    return np.where(input_grid == yellow)\n\ndef get_green_position(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    This function takes an input grid and returns the position of the green pixel in the form of a tuple (row, column).\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A tuple (row, column) representing the position of the green pixel.\n    \"\"\"\n    return np.where(input_grid == green)\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you can see a green pixel and a yellow pixel.\n    The output is the same size as the input.\n    To make the output, you have to...move the green square one block closer to the yellow square, no matter if it is horizontal, diagonal, or vertical.                                      \n    \"\"\"\n    output_grid = input_grid.copy()\n    pos_green = get_green_position(input_grid)\n    pos_yellow = get_yellow_position(input_grid)\n    output_grid = move_green_to_yellow(output_grid, pos_green, pos_yellow)\n    return output_grid"}
{"id": 287, "train_io": {"inputs": [[[0, 0, 0], [0, 2, 0], [2, 4, 2]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 8, 0, 0], [8, 8, 3, 8, 8]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 6, 6, 6, 0], [6, 1, 1, 1, 6]], [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0], [2, 2, 4, 4, 4, 2, 2]]], "outputs": [[[4, 0, 4], [0, 2, 0], [2, 4, 2]], [[0, 0, 0, 0, 0], [3, 0, 0, 0, 3], [0, 3, 0, 3, 0], [0, 0, 8, 0, 0], [8, 8, 3, 8, 8]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 1], [0, 6, 6, 6, 0], [6, 1, 1, 1, 6]], [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 4], [0, 4, 0, 0, 0, 4, 0], [0, 0, 2, 2, 2, 0, 0], [2, 2, 4, 4, 4, 2, 2]]]}, "test_io": {"inputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0], [8, 8, 8, 2, 2, 2, 8, 8, 8]]], "outputs": [[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 2], [0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 0, 2, 0, 0, 0, 2, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0], [8, 8, 8, 2, 2, 2, 8, 8, 8]]]}, "solved": true, "generalizable": false, "anpl": null, "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef set_element_to_color_of_first_element_of_last_line(input_grid: np.ndarray, positions: Tuple[Tuple[int, int], Tuple[int, int]]) -> np.ndarray:\n    color = find_element(input_grid, positions[0])\n    for i in range(positions[0][0], positions[1][0] + 1):\n        for j in range(positions[0][1], positions[1][1] + 1):\n            if input_grid[i][j] == color:\n                input_grid[i][j] = input_grid[-1][0]\n    return input_grid\n\ndef set_line_upper_right(input_grid: np.ndarray, position: Tuple[int, int], color: int) -> np.ndarray:\n    for i in range(position[1], len(input_grid)):\n        if input_grid[position[0]][i] != color:\n            input_grid[position[0] - (i - position[1])][i] = color\n        else:\n            break\n    return input_grid\n\ndef set_line_upper_left(input_grid: np.ndarray, position: Tuple[int, int], color: int) -> np.ndarray:\n    for i in range(position[1], -1, -1):\n        if input_grid[position[0]][i] != color:\n            input_grid[position[0] - position[1] + i][i] = color\n        else:\n            break\n    return input_grid\n\ndef find_element(input_grid: np.ndarray, position: Tuple[int, int]) -> int:\n    return input_grid[position[0] + 1][position[1]]\n\ndef find_penultimate_positions(input_grid: np.ndarray) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    penultimate_line = input_grid[-2]\n    first_pos = (len(penultimate_line) - 1, 0)\n    last_pos = (len(penultimate_line) - 1, len(penultimate_line) - 1)\n    for i in range(len(penultimate_line)):\n        if penultimate_line[i] != black:\n            first_pos = (len(penultimate_line) - 2, i)\n            break\n    for i in range(len(penultimate_line) - 1, -1, -1):\n        if penultimate_line[i] != black:\n            last_pos = (len(penultimate_line) - 2, i)\n            break\n    return (first_pos, last_pos)\n\ndef identity(input_grid: np.ndarray) -> np.ndarray:\n    return input_grid\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = identity(input_grid)\n    position_first, position_last = find_penultimate_positions(input_grid)\n    color = find_element(input_grid, position_first)\n    output_grid = set_line_upper_left(output_grid, position_first, color)\n    output_grid = set_line_upper_right(output_grid, position_last, color)\n    output_grid = set_element_to_color_of_first_element_of_last_line(output_grid, (position_first, position_last))\n    return output_grid"}